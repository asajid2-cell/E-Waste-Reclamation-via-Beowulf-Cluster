<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cluster Raytrace Viewer</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      :root {
        --bg: #060d1f;
        --card: #121d35;
        --line: #2a446d;
        --text: #e8efff;
        --muted: #a9bddf;
        --ok: #52b788;
        --warn: #ffb703;
        --err: #ef476f;
        --accent: #00b4d8;
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Segoe UI", Tahoma, sans-serif;
        color: var(--text);
        background: radial-gradient(circle at 20% 0%, #16325d, var(--bg) 45%);
      }
      .wrap {
        max-width: 1180px;
        margin: 1rem auto;
        padding: 0.8rem;
        display: grid;
        gap: 0.8rem;
      }
      .card {
        background: color-mix(in srgb, var(--card) 92%, black);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 0.8rem;
      }
      .title {
        margin: 0 0 0.35rem;
        font-size: 1.3rem;
      }
      .muted {
        color: var(--muted);
      }
      .ok {
        color: var(--ok);
      }
      .warn {
        color: var(--warn);
      }
      .err {
        color: var(--err);
      }
      .row {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        gap: 0.5rem;
      }
      .row-3 {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto auto;
        gap: 0.5rem;
      }
      input,
      button {
        border-radius: 8px;
        border: 1px solid #4c6898;
        padding: 0.55rem 0.7rem;
        font-size: 0.95rem;
      }
      input {
        background: #0e1a35;
        color: var(--text);
        width: 100%;
      }
      button {
        background: var(--accent);
        color: #001219;
        font-weight: 700;
        cursor: pointer;
      }
      button.secondary {
        background: #8ecae6;
      }
      .mono {
        font-family: Consolas, Menlo, monospace;
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 0.45rem 0.8rem;
      }
      .stat {
        min-width: 0;
      }
      .stat .k {
        color: var(--muted);
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .stat .v {
        font-weight: 700;
      }
      .canvas-wrap {
        display: none;
      }
      .canvas-wrap.active {
        display: block;
      }
      canvas {
        width: min(100%, 1100px);
        height: auto;
        background: #000;
        border: 1px solid #35507a;
        border-radius: 8px;
        image-rendering: pixelated;
      }
      .hint {
        margin: 0;
      }
      #log {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
        background: #0b1730;
        border: 1px solid #32547e;
        border-radius: 8px;
        padding: 0.6rem;
        min-height: 74px;
      }
      @media (max-width: 860px) {
        .row,
        .row-3 {
          grid-template-columns: 1fr;
        }
        .stats {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card">
        <h1 class="title">Live Raytrace Viewer</h1>
        <p class="muted hint">This tab waits for shard events and progressively refines the image as workers return tiles.</p>
        <div class="row-3">
          <input id="jobIdInput" class="mono" placeholder="job id" />
          <button id="attachBtn" type="button">Attach Job</button>
          <button id="clearBtn" class="secondary" type="button">Clear Frame</button>
        </div>
        <p class="hint">Status: <strong id="statusText" class="warn">idle</strong></p>
        <p class="hint">Job: <span id="jobText" class="mono">-</span></p>
      </div>

      <div class="card">
        <div class="stats">
          <div class="stat"><div class="k">Frame</div><div id="frameSize" class="v mono">-</div></div>
          <div class="stat"><div class="k">Events</div><div id="eventCount" class="v mono">0</div></div>
          <div class="stat"><div class="k">Completed Shards</div><div id="completedShards" class="v mono">0</div></div>
          <div class="stat"><div class="k">Samples</div><div id="sampleCount" class="v mono">0</div></div>
          <div class="stat"><div class="k">Pass</div><div id="passInfo" class="v mono">-</div></div>
          <div class="stat"><div class="k">Last Seq</div><div id="lastSeq" class="v mono">0</div></div>
          <div class="stat"><div class="k">Elapsed</div><div id="elapsedMs" class="v mono">0 ms</div></div>
          <div class="stat"><div class="k">Dropped</div><div id="droppedCount" class="v mono">0</div></div>
        </div>
      </div>

      <div class="card canvas-wrap" id="canvasWrap">
        <canvas id="frameCanvas" width="1" height="1"></canvas>
      </div>

      <div class="card">
        <pre id="log" class="mono">Waiting for job...</pre>
      </div>
    </div>

    <script>
      const TOKEN_KEY = "cluster_client_token";
      const path = window.location.pathname.replace(/\/+$/, "");
      const BASE_PATH = (() => {
        if (path.endsWith("/raytrace-viewer")) {
          return path.slice(0, -"/raytrace-viewer".length);
        }
        if (path.endsWith("/raytrace-viewer.html")) {
          return path.slice(0, -"/raytrace-viewer.html".length);
        }
        return "";
      })();
      function withBase(p) {
        return `${BASE_PATH}${p}`;
      }

      const jobIdInputEl = document.getElementById("jobIdInput");
      const attachBtnEl = document.getElementById("attachBtn");
      const clearBtnEl = document.getElementById("clearBtn");
      const statusTextEl = document.getElementById("statusText");
      const jobTextEl = document.getElementById("jobText");
      const frameSizeEl = document.getElementById("frameSize");
      const eventCountEl = document.getElementById("eventCount");
      const completedShardsEl = document.getElementById("completedShards");
      const sampleCountEl = document.getElementById("sampleCount");
      const passInfoEl = document.getElementById("passInfo");
      const lastSeqEl = document.getElementById("lastSeq");
      const elapsedMsEl = document.getElementById("elapsedMs");
      const droppedCountEl = document.getElementById("droppedCount");
      const canvasWrapEl = document.getElementById("canvasWrap");
      const canvasEl = document.getElementById("frameCanvas");
      const logEl = document.getElementById("log");
      const ctx = canvasEl.getContext("2d", { alpha: false });

      let activeJobId = "";
      let pollTimer = null;
      let pollInFlight = false;
      let lastSeq = 0;
      let frameWidth = 0;
      let frameHeight = 0;
      let frameData = null;
      let sumR = null;
      let sumG = null;
      let sumB = null;
      let sampleDen = null;
      let eventsSeen = 0;
      let completedShards = 0;
      let totalSamples = 0;
      let maxPassSeen = -1;
      let droppedEvents = 0;
      let startedAtMs = 0;

      function log(message) {
        logEl.textContent = `[${new Date().toLocaleTimeString()}] ${message}\n${logEl.textContent}`.slice(0, 6000);
      }

      function setStatus(text, cls = "warn") {
        statusTextEl.textContent = text;
        statusTextEl.className = cls;
      }

      function getToken() {
        return String(localStorage.getItem(TOKEN_KEY) || "").trim();
      }

      async function apiFetch(pathname) {
        const token = getToken();
        if (!token) {
          throw new Error("Missing client token in local storage.");
        }
        const res = await fetch(pathname, {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        let data = null;
        try {
          data = await res.json();
        } catch (_err) {
          data = { error: `Non-JSON response (${res.status})` };
        }
        if (!res.ok) {
          throw new Error(data.error || `Request failed (${res.status})`);
        }
        return data;
      }

      function resetFrameState() {
        frameWidth = 0;
        frameHeight = 0;
        frameData = null;
        sumR = null;
        sumG = null;
        sumB = null;
        sampleDen = null;
        eventsSeen = 0;
        completedShards = 0;
        totalSamples = 0;
        maxPassSeen = -1;
        droppedEvents = 0;
        lastSeq = 0;
        startedAtMs = Date.now();
        canvasWrapEl.classList.remove("active");
        frameSizeEl.textContent = "-";
        eventCountEl.textContent = "0";
        completedShardsEl.textContent = "0";
        sampleCountEl.textContent = "0";
        passInfoEl.textContent = "-";
        lastSeqEl.textContent = "0";
        droppedCountEl.textContent = "0";
        elapsedMsEl.textContent = "0 ms";
      }

      function ensureFrame(width, height) {
        const w = Number(width);
        const h = Number(height);
        if (!Number.isInteger(w) || !Number.isInteger(h) || w <= 0 || h <= 0) {
          return false;
        }
        if (frameWidth === w && frameHeight === h && frameData && sumR && sumG && sumB && sampleDen) {
          return true;
        }
        frameWidth = w;
        frameHeight = h;
        canvasEl.width = w;
        canvasEl.height = h;
        frameData = ctx.createImageData(w, h);
        sumR = new Float64Array(w * h);
        sumG = new Float64Array(w * h);
        sumB = new Float64Array(w * h);
        sampleDen = new Float64Array(w * h);
        frameSizeEl.textContent = `${w} x ${h}`;
        canvasWrapEl.classList.add("active");
        return true;
      }

      function applyTilePayload(payload) {
        if (!payload || payload.mode !== "raytrace_tile_v1") {
          return;
        }
        if (!ensureFrame(payload.width, payload.height)) {
          return;
        }
        const tileX = Number(payload.tileX);
        const tileY = Number(payload.tileY);
        const tileW = Number(payload.tileW);
        const tileH = Number(payload.tileH);
        const spp = Math.max(1, Number(payload.samplesPerPixel) || 1);
        const rgb = Array.isArray(payload.rgb8Sums) ? payload.rgb8Sums : null;
        if (!rgb || !Number.isInteger(tileX) || !Number.isInteger(tileY) || !Number.isInteger(tileW) || !Number.isInteger(tileH)) {
          return;
        }
        if (tileW <= 0 || tileH <= 0 || tileX < 0 || tileY < 0 || tileX + tileW > frameWidth || tileY + tileH > frameHeight) {
          return;
        }
        if (rgb.length !== tileW * tileH * 3) {
          return;
        }
        const data = frameData.data;
        let src = 0;
        for (let py = 0; py < tileH; py += 1) {
          const gy = tileY + py;
          for (let px = 0; px < tileW; px += 1) {
            const gx = tileX + px;
            const idx = gy * frameWidth + gx;
            sumR[idx] += Number(rgb[src]) || 0;
            sumG[idx] += Number(rgb[src + 1]) || 0;
            sumB[idx] += Number(rgb[src + 2]) || 0;
            sampleDen[idx] += spp;
            src += 3;

            const den = sampleDen[idx] > 0 ? sampleDen[idx] : 1;
            const di = idx * 4;
            data[di] = Math.max(0, Math.min(255, Math.round(sumR[idx] / den)));
            data[di + 1] = Math.max(0, Math.min(255, Math.round(sumG[idx] / den)));
            data[di + 2] = Math.max(0, Math.min(255, Math.round(sumB[idx] / den)));
            data[di + 3] = 255;
          }
        }
        ctx.putImageData(frameData, 0, 0, tileX, tileY, tileW, tileH);
        maxPassSeen = Math.max(maxPassSeen, Number(payload.passIndex) || 0);
        totalSamples += Number(payload.samplesDone || tileW * tileH * spp) || 0;
      }

      function updateStats() {
        eventCountEl.textContent = String(eventsSeen);
        completedShardsEl.textContent = String(completedShards);
        sampleCountEl.textContent = String(totalSamples);
        passInfoEl.textContent = maxPassSeen >= 0 ? `pass ${maxPassSeen + 1}` : "-";
        lastSeqEl.textContent = String(lastSeq);
        droppedCountEl.textContent = String(droppedEvents);
        elapsedMsEl.textContent = `${Math.max(0, Date.now() - startedAtMs)} ms`;
      }

      function handleEvent(evt) {
        eventsSeen += 1;
        if (evt.type === "shard_done") {
          completedShards = Math.max(completedShards, Number(evt.completedShards || completedShards));
          applyTilePayload(evt.result);
        } else if (evt.type === "job_done") {
          completedShards = Math.max(completedShards, Number(evt.completedShards || completedShards));
          setStatus("done", "ok");
          log("Job completed.");
        } else if (evt.type === "job_failed") {
          setStatus("failed", "err");
          log(`Job failed: ${evt.reason || "unknown error"}`);
        } else if (evt.type === "job_started") {
          log(`Job started with ${evt.totalShards || "?"} shards.`);
        } else if (evt.type === "shard_failed") {
          log(`Shard failed: ${evt.error || "worker error"}`);
        }
      }

      async function pollEventsOnce() {
        if (!activeJobId || pollInFlight) {
          return;
        }
        pollInFlight = true;
        try {
          let batches = 0;
          let keepPulling = true;
          while (keepPulling && batches < 4) {
            const data = await apiFetch(withBase(`/api/jobs/${encodeURIComponent(activeJobId)}/events?after=${lastSeq}&limit=128`));
            setStatus(data.status === "done" ? "done" : data.status === "failed" ? "failed" : "running", data.status === "failed" ? "err" : data.status === "done" ? "ok" : "warn");
            if (Number(data.droppedBeforeSeq || 0) > 0) {
              droppedEvents += Number(data.droppedBeforeSeq);
              log(`Missed ${data.droppedBeforeSeq} old events (viewer attached late).`);
            }
            const events = Array.isArray(data.events) ? data.events : [];
            if (events.length > 0) {
              for (const evt of events) {
                handleEvent(evt);
              }
              lastSeq = Number(events[events.length - 1].seq) || lastSeq;
            }
            batches += 1;
            keepPulling = Boolean(data.hasMore);
            if (events.length === 0) {
              keepPulling = false;
            }
            if ((data.status === "done" || data.status === "failed") && !keepPulling) {
              if (pollTimer) {
                clearInterval(pollTimer);
                pollTimer = null;
              }
            }
          }
        } catch (error) {
          setStatus("error", "err");
          log(error.message);
          if (String(error.message || "").includes("Missing client token")) {
            if (pollTimer) {
              clearInterval(pollTimer);
              pollTimer = null;
            }
          }
        } finally {
          updateStats();
          pollInFlight = false;
        }
      }

      function attachToJob(jobId) {
        const clean = String(jobId || "").trim();
        if (!clean) {
          setStatus("idle", "warn");
          return;
        }
        activeJobId = clean;
        jobTextEl.textContent = clean;
        jobIdInputEl.value = clean;
        resetFrameState();
        setStatus("connecting", "warn");
        log(`Attached to job ${clean}`);
        if (pollTimer) {
          clearInterval(pollTimer);
        }
        pollTimer = setInterval(pollEventsOnce, 350);
        pollEventsOnce();
      }

      attachBtnEl.addEventListener("click", () => {
        attachToJob(jobIdInputEl.value);
      });

      clearBtnEl.addEventListener("click", () => {
        resetFrameState();
        log("Frame cleared.");
      });

      const urlJobId = new URLSearchParams(window.location.search).get("jobId") || "";
      if (urlJobId) {
        attachToJob(urlJobId);
      } else {
        setStatus("waiting", "warn");
        log("No job selected. Paste a sharded raytrace job ID and click Attach Job.");
      }
    </script>
  </body>
</html>
