<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cluster Secure Client</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      :root {
        --bg: #0a1128;
        --card: #1b263b;
        --text: #f8f9fa;
        --muted: #c2cde3;
        --ok: #52b788;
        --warn: #ffb703;
        --err: #ef476f;
        --accent: #00b4d8;
      }
      body {
        margin: 0;
        font-family: "Segoe UI", Tahoma, sans-serif;
        color: var(--text);
        background: radial-gradient(circle at 20% 10%, #1f3f7a, var(--bg) 50%);
        min-height: 100vh;
      }
      .wrap {
        max-width: 860px;
        margin: 2rem auto;
        padding: 1rem;
        width: 100%;
      }
      .card {
        background: color-mix(in srgb, var(--card) 90%, black);
        border: 1px solid #35507a;
        border-radius: 12px;
        padding: 1rem;
        margin-bottom: 1rem;
        width: 100%;
      }
      h1 {
        margin: 0 0 0.3rem 0;
        font-size: 1.5rem;
      }
      p {
        margin: 0.35rem 0;
        color: var(--muted);
      }
      .row {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        gap: 0.5rem;
        width: 100%;
      }
      .stack {
        display: grid;
        gap: 0.6rem;
      }
      form {
        display: grid;
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) auto;
        gap: 0.6rem;
        width: 100%;
      }
      .custom-form {
        display: grid;
        gap: 0.6rem;
        width: 100%;
      }
      .script-options-row {
        display: grid;
        grid-template-columns: minmax(0, 1fr) minmax(140px, 180px) minmax(0, 1fr);
        gap: 0.6rem;
        align-items: center;
        width: 100%;
      }
      .settings-grid {
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) minmax(0, 220px);
      }
      .setting-cell {
        display: grid;
        gap: 0.35rem;
        align-items: start;
      }
      .setting-label {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        color: var(--muted);
        font-size: 0.82rem;
        letter-spacing: 0.02em;
        text-transform: uppercase;
      }
      .tip-wrap {
        position: relative;
        display: inline-flex;
        align-items: center;
      }
      .tip-trigger {
        width: 18px;
        height: 18px;
        border-radius: 999px;
        border: 1px solid #6c8cbe;
        padding: 0;
        font-size: 0.75rem;
        line-height: 1;
        background: #16305a;
        color: #cde7ff;
        cursor: help;
        font-weight: 700;
      }
      .tip-popup {
        position: absolute;
        left: 22px;
        top: -6px;
        width: min(250px, calc(100vw - 3rem));
        z-index: 20;
        opacity: 0;
        pointer-events: none;
        transform: translateY(4px);
        transition: opacity 120ms ease, transform 120ms ease;
        background: #0b1933;
        border: 1px solid #3f6293;
        border-radius: 8px;
        padding: 0.45rem 0.55rem;
        color: #dce8fb;
        font-size: 0.8rem;
        line-height: 1.25;
        text-transform: none;
        letter-spacing: normal;
        white-space: normal;
      }
      .tip-wrap:hover .tip-popup,
      .tip-wrap:focus-within .tip-popup {
        opacity: 1;
        transform: translateY(0);
      }
      .script-tip-block {
        display: grid;
        gap: 0.25rem;
        color: var(--muted);
        font-size: 0.86rem;
        overflow-wrap: anywhere;
      }
      .file-picker {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 0.6rem;
        align-items: center;
        width: 100%;
      }
      .file-picker input[type="file"] {
        display: none;
      }
      .file-name {
        color: var(--muted);
        overflow-wrap: anywhere;
      }
      input,
      select,
      button,
      textarea {
        border-radius: 8px;
        border: 1px solid #4c6898;
        padding: 0.6rem 0.8rem;
        font-size: 0.95rem;
        max-width: 100%;
      }
      input,
      select,
      textarea {
        background: #0e1a35;
        color: var(--text);
      }
      .hidden {
        display: none !important;
      }
      .guide-link-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.6rem;
        flex-wrap: wrap;
      }
      .hint {
        color: var(--muted);
        font-size: 0.9rem;
        overflow-wrap: anywhere;
      }
      .guide-code {
        margin: 0;
        background: #0d1730;
        border: 1px solid #365684;
        border-radius: 8px;
        padding: 0.7rem;
        color: var(--text);
        white-space: pre-wrap;
        word-break: break-word;
      }
      .guide-panel {
        border: 1px solid #35507a;
        border-radius: 10px;
        padding: 0.8rem;
        background: #101d39;
      }
      .guide-panel h3 {
        margin: 0;
        font-size: 1rem;
      }
      .script-inline-note {
        color: var(--muted);
        font-size: 0.85rem;
        display: flex;
        align-items: center;
        overflow-wrap: anywhere;
      }
      .raytrace-panel {
        border: 1px solid #35507a;
        border-radius: 10px;
        padding: 0.75rem;
        background: #101d39;
        display: grid;
        gap: 0.6rem;
      }
      .raytrace-grid {
        grid-template-columns: repeat(7, minmax(0, 1fr));
      }
      .raytrace-actions {
        display: grid;
        grid-template-columns: auto auto auto minmax(0, 1fr);
        gap: 0.6rem;
        align-items: center;
      }
      .raytrace-link {
        color: #9fd9ff;
      }
      button {
        background: var(--accent);
        color: #001219;
        font-weight: 700;
        cursor: pointer;
      }
      button.secondary {
        background: #8ecae6;
      }
      button.file-btn {
        border-color: #7fc6dd;
        background: linear-gradient(180deg, #9dd8eb, #78bfd8);
      }
      button.warn {
        background: var(--warn);
      }
      button:disabled {
        opacity: 0.6;
        cursor: default;
      }
      .mono {
        font-family: Consolas, Menlo, monospace;
      }
      .line {
        margin: 0.45rem 0;
      }
      .ok {
        color: var(--ok);
      }
      .err {
        color: var(--err);
      }
      .warn-text {
        color: var(--warn);
      }
      textarea {
        resize: vertical;
        min-height: 70px;
        width: 100%;
      }
      .row > *,
      form > *,
      .custom-form > *,
      .script-options-row > *,
      .settings-grid > *,
      .file-picker > * {
        min-width: 0;
        max-width: 100%;
      }
      input,
      select,
      textarea {
        width: 100%;
      }
      button {
        max-width: 100%;
      }
      #scriptCode {
        min-height: 160px;
        width: 100%;
      }
      .qr-panel {
        display: flex;
        gap: 0.8rem;
        align-items: center;
        flex-wrap: wrap;
      }
      #inviteQr {
        display: none;
        width: 220px;
        height: 220px;
        background: #fff;
        border-radius: 8px;
        padding: 6px;
      }
      #downloadQrLink {
        display: none;
        color: var(--text);
      }
      #result {
        display: block;
        white-space: pre-wrap;
        word-break: break-word;
      }
      @media (max-width: 780px) {
        form,
        .row,
        .script-options-row,
        .file-picker {
          grid-template-columns: 1fr;
        }
        .raytrace-grid,
        .raytrace-actions {
          grid-template-columns: 1fr;
        }
      }
      @media (max-width: 980px) {
        .settings-grid {
          grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
        }
        .settings-grid .script-tip-block {
          grid-column: 1 / -1;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card stack">
        <h1>Cluster Secure Client</h1>
        <p>Use your client token to submit jobs and generate worker invite links.</p>
        <div class="row">
          <input id="clientToken" placeholder="Client token or mnemonic phrase (required)" />
          <button id="saveTokenBtn" class="secondary" type="button">Save Token</button>
        </div>
        <p class="line">Auth status: <strong id="authStatus" class="warn-text">not checked</strong></p>
        <p class="line">Workers connected: <strong id="workerCount">0</strong></p>
        <div class="guide-link-row">
          <a id="openMetricsPageLink" class="mono" href="#" target="_blank" rel="noopener">Open Metrics Dashboard</a>
        </div>
      </div>

      <div class="card stack">
        <strong>Generate Worker Invite</strong>
        <div class="row">
          <input id="inviteTtl" type="number" min="60" max="86400" value="3600" placeholder="TTL seconds" />
          <button id="generateInviteBtn" type="button">Generate Invite URL</button>
        </div>
        <textarea id="phraseCode" class="mono" readonly placeholder="Worker phrase code (type words separated by spaces)"></textarea>
        <textarea id="phraseInviteUrl" class="mono" readonly placeholder="Worker phrase URL"></textarea>
        <textarea id="shortInviteUrl" class="mono" readonly placeholder="Short invite URL (easy to type)"></textarea>
        <textarea id="inviteUrl" class="mono" readonly placeholder="Invite URL will appear here"></textarea>
        <div class="qr-panel">
          <img id="inviteQr" alt="Worker invite QR code" />
          <a id="downloadQrLink" class="mono" download="worker-invite-qr.png">Download QR PNG</a>
        </div>
      </div>

      <div class="card stack">
        <strong>Submit Job (a + b)</strong>
        <form id="addJobForm">
          <input id="inputA" name="a" type="number" step="1" required placeholder="a (integer)" />
          <input id="inputB" name="b" type="number" step="1" required placeholder="b (integer)" />
          <button id="submitAddBtn" type="submit">Submit</button>
        </form>
      </div>

      <div class="card stack">
        <strong>Run Your Own JS (Signed)</strong>
        <div class="custom-form">
          <div class="file-picker">
            <input id="scriptFile" type="file" accept=".js,text/javascript" />
            <button id="scriptFileBtn" class="secondary file-btn" type="button">Choose JS File</button>
            <span id="scriptFileName" class="mono file-name">No file chosen</span>
          </div>
          <textarea
            id="scriptCode"
            class="mono"
            placeholder="Paste your JS here"
          >const units = Number(globalThis.__BRAIN__?.units || args.units || 1_000_000);
if (!Number.isFinite(units) || units <= 0) {
  throw new Error("units must be a positive number");
}
let hits = 0;
for (let i = 0; i < units; i += 1) {
  const x = Math.random();
  const y = Math.random();
  if (x * x + y * y <= 1) {
    hits += 1;
  }
}
return { hits, samples: units };</textarea>
          <div class="script-options-row">
            <input id="scriptTimeoutMs" type="number" min="0" step="1" placeholder="run timeout ms (optional, 0 = no timeout)" />
            <button id="submitScriptBtn" type="button">Run Script</button>
            <span id="autoModeHint" class="hint mono">Mode: auto single (default)</span>
          </div>
          <div class="script-options-row settings-grid">
            <div class="setting-cell">
              <label class="setting-label" for="shardTotalUnits">
                Total Units
                <span class="tip-wrap">
                  <button class="tip-trigger" type="button" aria-label="What is total units?">?</button>
                  <span class="tip-popup">Total amount of work across the full cluster run. Pi example: total random samples to throw.</span>
                </span>
              </label>
              <input id="shardTotalUnits" type="number" min="1" step="1" value="2000000" placeholder="e.g. 2000000" />
            </div>
            <div class="setting-cell">
              <label class="setting-label" for="shardUnitsPerShard">
                Units Per Shard
                <span class="tip-wrap">
                  <button class="tip-trigger" type="button" aria-label="What is units per shard?">?</button>
                  <span class="tip-popup">Work size for each shard job. Lower = more shards and better load balancing; too low adds overhead.</span>
                </span>
              </label>
              <input id="shardUnitsPerShard" type="number" min="1" step="1" value="20000" placeholder="e.g. 20000" />
            </div>
            <div class="setting-cell">
              <label class="setting-label" for="shardReducer">
                Reducer
                <span class="tip-wrap">
                  <button class="tip-trigger" type="button" aria-label="What is reducer?">?</button>
                  <span class="tip-popup">How shard results are combined: SUM for counts/math, COLLECT for all outputs, MIN/MAX for optimization metrics.</span>
                </span>
              </label>
              <select id="shardReducer">
                <option value="sum">SUM (counts / totals)</option>
                <option value="collect">COLLECT (all shard outputs)</option>
                <option value="min">MIN (lowest value)</option>
                <option value="max">MAX (highest value)</option>
              </select>
            </div>
          </div>
          <div class="script-options-row settings-grid">
            <div class="setting-cell">
              <label class="setting-label" for="shardSumFields">
                Sum Fields
                <span class="tip-wrap">
                  <button class="tip-trigger" type="button" aria-label="What are sum fields?">?</button>
                  <span class="tip-popup">Only for SUM reducer. Numeric fields to add from each shard result. For Pi use hits,samples. Use * to auto-sum all numeric top-level result fields.</span>
                </span>
              </label>
              <input id="shardSumFields" class="mono" value="hits,samples" placeholder="e.g. hits,samples or *" />
            </div>
            <div class="setting-cell">
              <label class="setting-label" for="scriptArgs">
                Args JSON
                <span class="tip-wrap">
                  <button class="tip-trigger" type="button" aria-label="What are args JSON?">?</button>
                  <span class="tip-popup">Optional parameters passed to script as args. Example: {\"seed\":123,\"samples\":1000000}</span>
                </span>
              </label>
              <input id="scriptArgs" class="mono" placeholder='optional, e.g. {"samples":1000000}' />
            </div>
            <div class="script-tip-block">
              <span>Auto mode: both shard fields empty = single; both filled = sharded.</span>
              <span>Safety guard: your units/shard is respected; hard shard-count limits still apply.</span>
            </div>
          </div>
          <div class="script-options-row">
            <div class="script-inline-note">For Pi: <span class="mono">&nbsp;total=2000000, shard=20000, reducer=sum, fields=hits,samples</span>.</div>
            <div></div>
            <div></div>
          </div>
          <div class="guide-link-row">
            <button id="toggleParallelGuideBtn" class="secondary" type="button">Show Parallel Guide</button>
            <a id="openGuidePageLink" class="mono" href="#" target="_blank" rel="noopener">Open Full Guide</a>
          </div>
          <div id="parallelGuidePanel" class="guide-panel hidden">
            <h3>How To Write Parallelizable Scripts</h3>
            <p class="hint">Mode auto-resolve: leave shard fields empty for single-worker; fill both shard fields for sharded cluster execution.</p>
            <p class="hint">Good pattern (slice-aware):</p>
            <pre class="guide-code">const units = Number(globalThis.__BRAIN__?.units || 1_000_000);
let hits = 0;
for (let i = 0; i &lt; units; i += 1) {
  const x = Math.random();
  const y = Math.random();
  if (x * x + y * y &lt;= 1) hits += 1;
}
return { hits, samples: units };</pre>
            <p class="hint">Bad pattern (hardcoded non-scalable work):</p>
            <pre class="guide-code">let hits = 0;
for (let i = 0; i &lt; 100000000; i += 1) {
  // hardcoded total means one huge shard and poor scaling
}
return hits;</pre>
            <p class="hint">Reducer tips: <span class="mono">sum</span> for counts/math, <span class="mono">collect</span> for per-shard outputs, <span class="mono">min/max</span> for optimization jobs.</p>
          </div>
          <div class="raytrace-panel">
            <strong>Live Raytrace (Cluster Progressive)</strong>
            <div class="script-options-row raytrace-grid">
              <div class="setting-cell">
                <label class="setting-label" for="rayScenePreset">
                  Scene
                  <span class="tip-wrap">
                    <button class="tip-trigger" type="button" aria-label="What is scene preset?">?</button>
                    <span class="tip-popup">Chooses geometry/material layout. More complex scenes increase compute cost per sample.</span>
                  </span>
                </label>
                <select id="rayScenePreset">
                  <option value="studio">Studio Spheres</option>
                  <option value="orb-garden">Orb Garden</option>
                  <option value="corridor">Box Corridor</option>
                  <option value="neon-night">Neon Night</option>
                  <option value="stacked-world">Stacked World</option>
                </select>
              </div>
              <div class="setting-cell">
                <label class="setting-label" for="rayWidth">
                  Width
                  <span class="tip-wrap">
                    <button class="tip-trigger" type="button" aria-label="What is render width?">?</button>
                    <span class="tip-popup">Output image width in pixels. Higher width means more tiles and more total work.</span>
                  </span>
                </label>
                <input id="rayWidth" type="number" min="64" step="1" value="320" />
              </div>
              <div class="setting-cell">
                <label class="setting-label" for="rayHeight">
                  Height
                  <span class="tip-wrap">
                    <button class="tip-trigger" type="button" aria-label="What is render height?">?</button>
                    <span class="tip-popup">Output image height in pixels. Total rays scale with width x height.</span>
                  </span>
                </label>
                <input id="rayHeight" type="number" min="64" step="1" value="180" />
              </div>
              <div class="setting-cell">
                <label class="setting-label" for="rayTileSize">
                  Tile
                  <span class="tip-wrap">
                    <button class="tip-trigger" type="button" aria-label="What is tile size?">?</button>
                    <span class="tip-popup">Tile width/height in pixels per tile job unit. Smaller tiles improve balancing; larger tiles reduce scheduling overhead.</span>
                  </span>
                </label>
                <input id="rayTileSize" type="number" min="4" step="1" value="20" />
              </div>
              <div class="setting-cell">
                <label class="setting-label" for="raySamplesPerShard">
                  SPP / Shard
                  <span class="tip-wrap">
                    <button class="tip-trigger" type="button" aria-label="What is samples per pixel per shard?">?</button>
                    <span class="tip-popup">Samples per pixel each shard contributes to its tile. Higher values reduce noise but increase shard runtime.</span>
                  </span>
                </label>
                <input id="raySamplesPerShard" type="number" min="1" step="1" value="2" />
              </div>
              <div class="setting-cell">
                <label class="setting-label" for="rayPasses">
                  Passes
                  <span class="tip-wrap">
                    <button class="tip-trigger" type="button" aria-label="What is pass count?">?</button>
                    <span class="tip-popup">How many refinement rounds across all tiles. More passes progressively clean up noise.</span>
                  </span>
                </label>
                <input id="rayPasses" type="number" min="1" step="1" value="20" />
              </div>
              <div class="setting-cell">
                <label class="setting-label" for="rayMaxBounces">
                  Bounces
                  <span class="tip-wrap">
                    <button class="tip-trigger" type="button" aria-label="What is max bounces?">?</button>
                    <span class="tip-popup">Max path-tracing bounce depth. Higher bounces improve indirect lighting realism but cost much more CPU.</span>
                  </span>
                </label>
                <input id="rayMaxBounces" type="number" min="1" step="1" value="3" />
              </div>
            </div>
            <div class="raytrace-actions">
              <button id="startRaytraceBtn" class="warn" type="button">Start Live Raytrace + Open Viewer</button>
              <button id="stopAllJobsBtn" class="secondary" type="button">Stop All Jobs</button>
              <a id="openRaytraceViewerLink" class="mono raytrace-link" href="#" target="_blank" rel="noopener">Open Raytrace Viewer</a>
              <span id="raytraceHint" class="hint mono">Viewer waits for shard events and refines image in real time.</span>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <p class="line">Job ID: <span class="mono" id="jobId">-</span></p>
        <p class="line">Task Type: <strong id="taskType">-</strong></p>
        <p class="line">Execution: <strong id="executionModel">-</strong></p>
        <p class="line">Status: <strong id="status">idle</strong></p>
        <p class="line">Result: <span class="mono" id="result">-</span></p>
        <p class="line">Error: <span id="error">-</span></p>
      </div>
    </div>

    <script>
      const TOKEN_KEY = "cluster_client_token";
      const BASE_PATH = (() => {
        const path = window.location.pathname.replace(/\/+$/, "");
        if (path.endsWith("/client")) {
          return path.slice(0, -"/client".length);
        }
        return "";
      })();

      function withBase(path) {
        return `${BASE_PATH}${path}`;
      }

      const clientTokenEl = document.getElementById("clientToken");
      const saveTokenBtn = document.getElementById("saveTokenBtn");
      const authStatusEl = document.getElementById("authStatus");
      const workerCountEl = document.getElementById("workerCount");

      const inviteTtlEl = document.getElementById("inviteTtl");
      const generateInviteBtn = document.getElementById("generateInviteBtn");
      const phraseCodeEl = document.getElementById("phraseCode");
      const phraseInviteUrlEl = document.getElementById("phraseInviteUrl");
      const shortInviteUrlEl = document.getElementById("shortInviteUrl");
      const inviteUrlEl = document.getElementById("inviteUrl");
      const inviteQrEl = document.getElementById("inviteQr");
      const downloadQrLinkEl = document.getElementById("downloadQrLink");

      const addJobForm = document.getElementById("addJobForm");
      const inputA = document.getElementById("inputA");
      const inputB = document.getElementById("inputB");
      const submitAddBtn = document.getElementById("submitAddBtn");

      const scriptFileEl = document.getElementById("scriptFile");
      const scriptFileBtnEl = document.getElementById("scriptFileBtn");
      const scriptFileNameEl = document.getElementById("scriptFileName");
      const scriptCodeEl = document.getElementById("scriptCode");
      const scriptArgsEl = document.getElementById("scriptArgs");
      const scriptTimeoutMsEl = document.getElementById("scriptTimeoutMs");
      const autoModeHintEl = document.getElementById("autoModeHint");
      const shardTotalUnitsEl = document.getElementById("shardTotalUnits");
      const shardUnitsPerShardEl = document.getElementById("shardUnitsPerShard");
      const shardReducerEl = document.getElementById("shardReducer");
      const shardSumFieldsEl = document.getElementById("shardSumFields");
      const toggleParallelGuideBtnEl = document.getElementById("toggleParallelGuideBtn");
      const parallelGuidePanelEl = document.getElementById("parallelGuidePanel");
      const openGuidePageLinkEl = document.getElementById("openGuidePageLink");
      const openMetricsPageLinkEl = document.getElementById("openMetricsPageLink");
      const submitScriptBtn = document.getElementById("submitScriptBtn");
      const rayScenePresetEl = document.getElementById("rayScenePreset");
      const rayWidthEl = document.getElementById("rayWidth");
      const rayHeightEl = document.getElementById("rayHeight");
      const rayTileSizeEl = document.getElementById("rayTileSize");
      const raySamplesPerShardEl = document.getElementById("raySamplesPerShard");
      const rayPassesEl = document.getElementById("rayPasses");
      const rayMaxBouncesEl = document.getElementById("rayMaxBounces");
      const startRaytraceBtnEl = document.getElementById("startRaytraceBtn");
      const stopAllJobsBtnEl = document.getElementById("stopAllJobsBtn");
      const openRaytraceViewerLinkEl = document.getElementById("openRaytraceViewerLink");
      const raytraceHintEl = document.getElementById("raytraceHint");

      const taskTypeEl = document.getElementById("taskType");
      const executionModelEl = document.getElementById("executionModel");
      const jobIdEl = document.getElementById("jobId");
      const statusEl = document.getElementById("status");
      const resultEl = document.getElementById("result");
      const errorEl = document.getElementById("error");

      const SHARD_MIN_UNITS = 1;
      const SHARD_MAX_PER_WORKER = 200;
      const SHARD_ABSOLUTE_MAX = Number.MAX_SAFE_INTEGER;
      const RAYTRACE_VIEWER_HTML_PATH = "/raytrace-viewer.html";
      const RAYTRACE_SCENE_JOBS_KEY = "cluster_raytrace_scene_jobs_v1";
      const DEFAULT_RAYTRACE_RESULT_LIMIT_BYTES = 64 * 1024;

      let currentJobId = null;
      let pollTimer = null;
      let workersTimer = null;
      let stopAllInFlight = false;
      let activeRaytraceSceneKey = null;
      let publicMaxResultBytes = DEFAULT_RAYTRACE_RESULT_LIMIT_BYTES;
      let raytraceJobsByScene = (() => {
        try {
          const parsed = JSON.parse(localStorage.getItem(RAYTRACE_SCENE_JOBS_KEY) || "{}");
          if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
            return {};
          }
          return parsed;
        } catch (_err) {
          return {};
        }
      })();

      function saveRaytraceSceneJobs() {
        localStorage.setItem(RAYTRACE_SCENE_JOBS_KEY, JSON.stringify(raytraceJobsByScene));
      }

      function sceneKeyFromSettings(settings) {
        return [
          settings.scenePreset,
          `${settings.width}x${settings.height}`,
          `tile=${settings.tileSize}`,
          `spp=${settings.samplesPerShard}`,
          `bounces=${settings.maxBounces}`,
          `passes=${settings.passes}`,
        ].join("|");
      }

      function rememberSceneJob(sceneKey, jobId) {
        if (!sceneKey || !jobId) {
          return;
        }
        raytraceJobsByScene[sceneKey] = jobId;
        saveRaytraceSceneJobs();
      }

      function removeSceneJobById(jobId) {
        let changed = false;
        for (const [sceneKey, storedJobId] of Object.entries(raytraceJobsByScene)) {
          if (storedJobId === jobId) {
            delete raytraceJobsByScene[sceneKey];
            changed = true;
          }
        }
        if (changed) {
          saveRaytraceSceneJobs();
        }
      }

      function raytraceViewerUrl(jobId) {
        const base = withBase(RAYTRACE_VIEWER_HTML_PATH);
        if (!jobId) {
          return base;
        }
        return `${base}?jobId=${encodeURIComponent(jobId)}`;
      }

      function updateRaytraceViewerLink() {
        openRaytraceViewerLinkEl.href = raytraceViewerUrl(currentJobId);
        if (currentJobId) {
          raytraceHintEl.textContent = `Live viewer ready for job ${currentJobId}`;
          raytraceHintEl.className = "hint mono ok";
        } else {
          raytraceHintEl.textContent = "Viewer waits for shard events and refines image in real time.";
          raytraceHintEl.className = "hint mono";
        }
      }

      function clampInt(value, minValue, maxValue, fallback) {
        const n = Number(value);
        if (!Number.isInteger(n)) {
          return fallback;
        }
        return Math.max(minValue, Math.min(maxValue, n));
      }

      function getRaytraceSettings() {
        const scenePreset = String(rayScenePresetEl.value || "studio").trim().toLowerCase();
        const width = clampInt(rayWidthEl.value, 64, 1920, 320);
        const height = clampInt(rayHeightEl.value, 64, 1080, 180);
        const tileSize = clampInt(rayTileSizeEl.value, 4, 128, 16);
        const samplesPerShard = clampInt(raySamplesPerShardEl.value, 1, 128, 2);
        const passes = clampInt(rayPassesEl.value, 1, 20000, 40);
        const maxBounces = clampInt(rayMaxBouncesEl.value, 1, 8, 3);
        return {
          scenePreset,
          width,
          height,
          tileSize,
          samplesPerShard,
          passes,
          maxBounces,
        };
      }

      function estimateRaytraceTilePayloadBytes(settings) {
        const tilePixels = settings.tileSize * settings.tileSize;
        const maxValue = Math.max(255, settings.samplesPerShard * 255);
        const avgCharsPerNumber = String(maxValue).length + 1;
        const rgbArrayChars = tilePixels * 3 * avgCharsPerNumber;
        return rgbArrayChars + 2048;
      }

      function buildRaytraceScript() {
        return `const brain = globalThis.__BRAIN__ || {};
const cfg = args && typeof args === "object" ? args : {};
const scenePreset = String(cfg.scenePreset || "studio").toLowerCase();
const width = Math.max(64, Math.min(1920, Number(cfg.width) || 320)) | 0;
const height = Math.max(64, Math.min(1080, Number(cfg.height) || 180)) | 0;
const tileSize = Math.max(4, Math.min(128, Number(cfg.tileSize) || 16)) | 0;
const spp = Math.max(1, Math.min(128, Number(cfg.samplesPerShard) || 2)) | 0;
const maxBounces = Math.max(1, Math.min(8, Number(cfg.maxBounces) || 3)) | 0;
const units = Math.max(1, Math.floor(Number(brain.units) || 1));
const shardOffset = Math.max(
  0,
  Math.floor(Number.isFinite(Number(brain.offset)) ? Number(brain.offset) : Number(brain.shardId || 0)),
);
const tilesX = Math.ceil(width / tileSize);
const tilesY = Math.ceil(height / tileSize);
const totalTiles = Math.max(1, tilesX * tilesY);

function makeRng(seed) {
  let s = (seed >>> 0) || 1;
  return function rand() {
    s = (1664525 * s + 1013904223) >>> 0;
    return (s & 0x00ffffff) / 0x01000000;
  };
}
function dot(ax, ay, az, bx, by, bz) { return ax * bx + ay * by + az * bz; }
function len(x, y, z) { return Math.sqrt(dot(x, y, z, x, y, z)); }
function normalize(x, y, z) {
  const l = len(x, y, z) || 1;
  return [x / l, y / l, z / l];
}
function cross(ax, ay, az, bx, by, bz) {
  return [ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx];
}
function reflect(ix, iy, iz, nx, ny, nz) {
  const d = 2 * dot(ix, iy, iz, nx, ny, nz);
  return [ix - d * nx, iy - d * ny, iz - d * nz];
}
function sphereHit(ro, rd, cx, cy, cz, r, material) {
  const ocx = ro[0] - cx, ocy = ro[1] - cy, ocz = ro[2] - cz;
  const b = dot(ocx, ocy, ocz, rd[0], rd[1], rd[2]);
  const c = dot(ocx, ocy, ocz, ocx, ocy, ocz) - r * r;
  const h = b * b - c;
  if (h < 0) return null;
  let t = -b - Math.sqrt(h);
  if (t <= 1e-4) {
    t = -b + Math.sqrt(h);
    if (t <= 1e-4) return null;
  }
  const px = ro[0] + rd[0] * t, py = ro[1] + rd[1] * t, pz = ro[2] + rd[2] * t;
  const nn = normalize(px - cx, py - cy, pz - cz);
  return { t, px, py, pz, nx: nn[0], ny: nn[1], nz: nn[2], material };
}
function planeHit(ro, rd, px, py, pz, nx, ny, nz, material) {
  const denom = dot(rd[0], rd[1], rd[2], nx, ny, nz);
  if (Math.abs(denom) < 1e-6) return null;
  const t = dot(px - ro[0], py - ro[1], pz - ro[2], nx, ny, nz) / denom;
  if (t <= 1e-4) return null;
  const hx = ro[0] + rd[0] * t, hy = ro[1] + rd[1] * t, hz = ro[2] + rd[2] * t;
  const normal = denom < 0 ? [nx, ny, nz] : [-nx, -ny, -nz];
  return { t, px: hx, py: hy, pz: hz, nx: normal[0], ny: normal[1], nz: normal[2], material };
}
function boxHit(ro, rd, bmin, bmax, material) {
  let tmin = -1e30;
  let tmax = 1e30;
  let nearNormal = [0, 0, 0];
  let farNormal = [0, 0, 0];
  for (let axis = 0; axis < 3; axis += 1) {
    const inv = Math.abs(rd[axis]) > 1e-9 ? 1 / rd[axis] : 1e30;
    let t1 = (bmin[axis] - ro[axis]) * inv;
    let t2 = (bmax[axis] - ro[axis]) * inv;
    let n1 = [0, 0, 0];
    let n2 = [0, 0, 0];
    n1[axis] = -1;
    n2[axis] = 1;
    if (t1 > t2) {
      const tmpT = t1; t1 = t2; t2 = tmpT;
      const tmpN = n1; n1 = n2; n2 = tmpN;
    }
    if (t1 > tmin) {
      tmin = t1;
      nearNormal = n1;
    }
    if (t2 < tmax) {
      tmax = t2;
      farNormal = n2;
    }
    if (tmax < tmin) return null;
  }
  let t = tmin;
  let n = nearNormal;
  if (t <= 1e-4) {
    t = tmax;
    n = farNormal;
    if (t <= 1e-4) return null;
  }
  const hx = ro[0] + rd[0] * t, hy = ro[1] + rd[1] * t, hz = ro[2] + rd[2] * t;
  return { t, px: hx, py: hy, pz: hz, nx: n[0], ny: n[1], nz: n[2], material };
}
function mat(albedo, options) {
  const opt = options || {};
  return {
    albedo: albedo || [0.7, 0.7, 0.7],
    emission: opt.emission || [0, 0, 0],
    metalness: Number(opt.metalness) || 0,
    roughness: Number(opt.roughness) || 0,
  };
}
function sceneForPreset(name) {
  const objects = [];
  let camera = { pos: [0, 1.15, 4.2], target: [0, 0.8, 0], fovDeg: 46 };
  let sun = normalize(0.95, 1.2, 0.55);
  let skyTop = [0.78, 0.86, 1.0];
  let skyBottom = [0.2, 0.26, 0.4];
  function addSphere(x, y, z, r, material) { objects.push({ kind: "sphere", x, y, z, r, material }); }
  function addPlane(px, py, pz, nx, ny, nz, material) { objects.push({ kind: "plane", px, py, pz, nx, ny, nz, material }); }
  function addBox(minArr, maxArr, material) { objects.push({ kind: "box", min: minArr, max: maxArr, material }); }

  if (name === "orb-garden") {
    camera = { pos: [0.2, 2.2, 7.7], target: [0, 0.7, -1.4], fovDeg: 40 };
    sun = normalize(0.35, 1.0, -0.25);
    skyTop = [0.9, 0.86, 0.74];
    skyBottom = [0.21, 0.22, 0.34];
    addPlane(0, 0, 0, 0, 1, 0, mat([0.82, 0.84, 0.9]));
    const rg = makeRng(123456);
    for (let z = -5; z <= 2; z += 1) {
      for (let x = -4; x <= 4; x += 1) {
        const rr = 0.19 + rg() * 0.22;
        const ox = (rg() - 0.5) * 0.22;
        const oz = (rg() - 0.5) * 0.22;
        const h = rr;
        const albedo = [0.25 + rg() * 0.7, 0.25 + rg() * 0.7, 0.25 + rg() * 0.7];
        const metalness = rg() > 0.8 ? 0.85 : 0;
        const roughness = metalness > 0 ? 0.03 + rg() * 0.2 : 0.5 + rg() * 0.45;
        addSphere(x + ox, h, z + oz, rr, mat(albedo, { metalness, roughness }));
      }
    }
    addSphere(0, 2.9, -2.2, 0.45, mat([1, 1, 1], { emission: [6.2, 5.7, 4.4] }));
  } else if (name === "corridor") {
    camera = { pos: [0, 1.1, 6.3], target: [0, 1.0, -2.0], fovDeg: 43 };
    sun = normalize(0.2, 1.0, -0.35);
    skyTop = [0.62, 0.71, 0.82];
    skyBottom = [0.09, 0.11, 0.17];
    addPlane(0, 0, 0, 0, 1, 0, mat([0.74, 0.74, 0.74]));
    addPlane(-2.7, 0, 0, 1, 0, 0, mat([0.66, 0.25, 0.22]));
    addPlane(2.7, 0, 0, -1, 0, 0, mat([0.2, 0.3, 0.68]));
    for (let i = 0; i < 7; i += 1) {
      const z = -1.2 - i * 1.55;
      addBox([-1.95, 0, z - 0.4], [-1.15, 1.8 + (i % 2) * 0.55, z + 0.4], mat([0.74, 0.74, 0.79]));
      addBox([1.15, 0, z - 0.4], [1.95, 1.8 + ((i + 1) % 2) * 0.55, z + 0.4], mat([0.74, 0.74, 0.79]));
      addSphere(0, 2.7, z, 0.22, mat([1, 1, 1], { emission: [5.0, 5.2, 5.6] }));
    }
    addSphere(0, 0.9, -3.0, 0.9, mat([0.85, 0.83, 0.3], { metalness: 0.9, roughness: 0.06 }));
  } else if (name === "neon-night") {
    camera = { pos: [0.4, 1.0, 4.8], target: [0, 0.75, 0], fovDeg: 47 };
    sun = normalize(-0.6, 0.95, 0.2);
    skyTop = [0.16, 0.11, 0.28];
    skyBottom = [0.02, 0.02, 0.05];
    addPlane(0, 0, 0, 0, 1, 0, mat([0.08, 0.08, 0.1], { metalness: 0.35, roughness: 0.2 }));
    addSphere(-1.7, 0.7, -0.8, 0.7, mat([0.18, 0.22, 0.95], { emission: [0.0, 0.0, 3.6] }));
    addSphere(0.0, 0.95, -0.1, 0.95, mat([0.95, 0.25, 0.75], { metalness: 0.2, roughness: 0.3 }));
    addSphere(1.65, 0.65, -0.55, 0.65, mat([0.25, 0.95, 0.72], { emission: [0.0, 2.8, 1.7] }));
    addSphere(-0.2, 1.95, -2.0, 0.45, mat([1, 1, 1], { emission: [5.6, 3.1, 6.0] }));
    for (let i = 0; i < 10; i += 1) {
      const z = -0.6 - i * 0.8;
      const x = (i % 2 === 0 ? -2.25 : 2.25);
      const c = i % 3;
      const em = c === 0 ? [3.6, 0.4, 4.2] : c === 1 ? [0.3, 3.8, 2.8] : [3.2, 2.1, 0.3];
      addSphere(x, 0.3, z, 0.16, mat([1, 1, 1], { emission: em }));
    }
  } else if (name === "stacked-world") {
    camera = { pos: [0.0, 3.6, 8.3], target: [0, 1.1, -1.8], fovDeg: 36 };
    sun = normalize(0.48, 1.0, -0.22);
    skyTop = [0.86, 0.92, 1.0];
    skyBottom = [0.16, 0.2, 0.3];
    addPlane(0, 0, 0, 0, 1, 0, mat([0.9, 0.9, 0.92]));
    for (let level = 0; level < 6; level += 1) {
      const y = 0.28 + level * 0.48;
      const radius = 2.2 - level * 0.27;
      const count = 10 + level * 2;
      for (let i = 0; i < count; i += 1) {
        const a = (i / count) * Math.PI * 2 + level * 0.12;
        const x = Math.cos(a) * radius;
        const z = Math.sin(a) * radius - 2.2;
        const r = 0.16 + (i % 3) * 0.03;
        const t = (i + level) % 6;
        const albedo = [
          0.25 + (t === 0 || t === 3 ? 0.65 : 0.15),
          0.25 + (t === 1 || t === 4 ? 0.65 : 0.15),
          0.25 + (t === 2 || t === 5 ? 0.65 : 0.15),
        ];
        addSphere(x, y, z, r, mat(albedo, { roughness: 0.45 + (level * 0.05) }));
      }
    }
    addSphere(0, 3.2, -2.2, 0.65, mat([0.95, 0.9, 0.6], { emission: [2.2, 1.9, 1.2] }));
  } else {
    addPlane(0, 0, 0, 0, 1, 0, mat([0.82, 0.82, 0.82]));
    addSphere(0.0, 0.9, 0.0, 0.9, mat([0.95, 0.32, 0.28], { roughness: 0.45 }));
    addSphere(-1.6, 0.65, -0.3, 0.65, mat([0.25, 0.52, 0.95], { roughness: 0.4 }));
    addSphere(1.55, 0.55, 0.3, 0.55, mat([0.88, 0.84, 0.3], { metalness: 0.9, roughness: 0.08 }));
    addSphere(0.2, 2.7, -1.9, 0.42, mat([1, 1, 1], { emission: [5.4, 4.9, 4.2] }));
    addBox([-0.45, 0.0, -2.95], [0.45, 0.95, -2.05], mat([0.2, 0.85, 0.72], { roughness: 0.18 }));
  }
  return { camera, sun, skyTop, skyBottom, objects };
}
const SCENE = sceneForPreset(scenePreset);

function hitScene(ro, rd) {
  let best = null;
  for (let i = 0; i < SCENE.objects.length; i += 1) {
    const obj = SCENE.objects[i];
    let hit = null;
    if (obj.kind === "sphere") {
      hit = sphereHit(ro, rd, obj.x, obj.y, obj.z, obj.r, obj.material);
    } else if (obj.kind === "plane") {
      hit = planeHit(ro, rd, obj.px, obj.py, obj.pz, obj.nx, obj.ny, obj.nz, obj.material);
    } else if (obj.kind === "box") {
      hit = boxHit(ro, rd, obj.min, obj.max, obj.material);
    }
    if (!hit) continue;
    if (!best || hit.t < best.t) {
      best = hit;
    }
  }
  return best;
}
function cosineHemisphere(nx, ny, nz, rng) {
  const u = rng();
  const v = rng();
  const r = Math.sqrt(u);
  const theta = 2 * Math.PI * v;
  const x = r * Math.cos(theta);
  const y = r * Math.sin(theta);
  const z = Math.sqrt(Math.max(0, 1 - u));
  const up = Math.abs(ny) < 0.999 ? [0, 1, 0] : [1, 0, 0];
  let t = cross(up[0], up[1], up[2], nx, ny, nz);
  t = normalize(t[0], t[1], t[2]);
  let b = cross(nx, ny, nz, t[0], t[1], t[2]);
  b = normalize(b[0], b[1], b[2]);
  return normalize(
    t[0] * x + b[0] * y + nx * z,
    t[1] * x + b[1] * y + ny * z,
    t[2] * x + b[2] * y + nz * z,
  );
}
function sky(dirY) {
  const t = Math.max(0, Math.min(1, 0.5 * (dirY + 1)));
  return [
    SCENE.skyBottom[0] + (SCENE.skyTop[0] - SCENE.skyBottom[0]) * t,
    SCENE.skyBottom[1] + (SCENE.skyTop[1] - SCENE.skyBottom[1]) * t,
    SCENE.skyBottom[2] + (SCENE.skyTop[2] - SCENE.skyBottom[2]) * t,
  ];
}
function trace(ro, rd, rng, bounces) {
  let thrR = 1, thrG = 1, thrB = 1;
  let outR = 0, outG = 0, outB = 0;
  const sun = SCENE.sun;
  for (let bounce = 0; bounce < bounces; bounce += 1) {
    const hit = hitScene(ro, rd);
    if (!hit) {
      const s = sky(rd[1]);
      outR += thrR * s[0];
      outG += thrG * s[1];
      outB += thrB * s[2];
      break;
    }
    const matRef = hit.material || mat([0.8, 0.8, 0.8]);
    outR += thrR * (matRef.emission[0] || 0);
    outG += thrG * (matRef.emission[1] || 0);
    outB += thrB * (matRef.emission[2] || 0);

    const eps = 1e-3;
    const sro = [hit.px + hit.nx * eps, hit.py + hit.ny * eps, hit.pz + hit.nz * eps];
    const shadow = hitScene(sro, sun);
    const visibleSun = !shadow || shadow.t > 80;
    if (visibleSun) {
      const ndotl = Math.max(0, dot(hit.nx, hit.ny, hit.nz, sun[0], sun[1], sun[2]));
      const intensity = 1.1 * ndotl;
      outR += thrR * matRef.albedo[0] * intensity;
      outG += thrG * matRef.albedo[1] * intensity;
      outB += thrB * matRef.albedo[2] * intensity;
    }

    thrR *= matRef.albedo[0];
    thrG *= matRef.albedo[1];
    thrB *= matRef.albedo[2];
    if (bounce >= 2) {
      const p = Math.max(thrR, thrG, thrB);
      if (rng() > p) break;
      const inv = p > 0 ? 1 / p : 1;
      thrR *= inv; thrG *= inv; thrB *= inv;
    }

    let next;
    if ((matRef.metalness || 0) > 0.5) {
      const refl = reflect(rd[0], rd[1], rd[2], hit.nx, hit.ny, hit.nz);
      const fuzz = Math.max(0, Math.min(1, matRef.roughness || 0.02)) * 0.35;
      next = normalize(
        refl[0] + (rng() * 2 - 1) * fuzz,
        refl[1] + (rng() * 2 - 1) * fuzz,
        refl[2] + (rng() * 2 - 1) * fuzz,
      );
    } else {
      next = cosineHemisphere(hit.nx, hit.ny, hit.nz, rng);
    }
    ro = sro;
    rd = next;
  }
  return [outR, outG, outB];
}

const camPos = SCENE.camera.pos;
const camTarget = SCENE.camera.target;
const forward = normalize(camTarget[0] - camPos[0], camTarget[1] - camPos[1], camTarget[2] - camPos[2]);
const worldUp = [0, 1, 0];
let rightRaw = cross(forward[0], forward[1], forward[2], worldUp[0], worldUp[1], worldUp[2]);
if (len(rightRaw[0], rightRaw[1], rightRaw[2]) < 1e-6) {
  rightRaw = [1, 0, 0];
}
const right = normalize(rightRaw[0], rightRaw[1], rightRaw[2]);
const upRaw = cross(right[0], right[1], right[2], forward[0], forward[1], forward[2]);
const up = normalize(upRaw[0], upRaw[1], upRaw[2]);
const fov = (SCENE.camera.fovDeg || 46) * Math.PI / 180;
const invW = 1 / width;
const invH = 1 / height;
const aspect = width / height;
const scale = Math.tan(fov * 0.5);

function renderTileForOrdinal(shardOrdinal) {
  const tileIndex = shardOrdinal % totalTiles;
  const passIndex = Math.floor(shardOrdinal / totalTiles);
  const tileX = (tileIndex % tilesX) * tileSize;
  const tileY = Math.floor(tileIndex / tilesX) * tileSize;
  const tileW = Math.min(tileSize, width - tileX);
  const tileH = Math.min(tileSize, height - tileY);
  if (tileW <= 0 || tileH <= 0) {
    return null;
  }

  const rgb8Sums = new Array(tileW * tileH * 3).fill(0);
  for (let py = 0; py < tileH; py += 1) {
    for (let px = 0; px < tileW; px += 1) {
      const gx = tileX + px;
      const gy = tileY + py;
      let sR = 0, sG = 0, sB = 0;
      for (let s = 0; s < spp; s += 1) {
        const seed =
          ((passIndex + 1) * 73856093) ^
          ((gx + 1) * 19349663) ^
          ((gy + 1) * 83492791) ^
          ((s + 17) * 2654435761);
        const rng = makeRng(seed >>> 0);
        const jx = (gx + rng()) * invW;
        const jy = (gy + rng()) * invH;
        const sx = (2 * jx - 1) * aspect * scale;
        const sy = (1 - 2 * jy) * scale;
        const dir = normalize(
          forward[0] + right[0] * sx + up[0] * sy,
          forward[1] + right[1] * sx + up[1] * sy,
          forward[2] + right[2] * sx + up[2] * sy,
        );
        const c = trace([camPos[0], camPos[1], camPos[2]], dir, rng, maxBounces);
        const gR = Math.pow(Math.max(0, Math.min(1, c[0])), 1 / 2.2);
        const gG = Math.pow(Math.max(0, Math.min(1, c[1])), 1 / 2.2);
        const gB = Math.pow(Math.max(0, Math.min(1, c[2])), 1 / 2.2);
        sR += Math.round(gR * 255);
        sG += Math.round(gG * 255);
        sB += Math.round(gB * 255);
      }
      const off = (py * tileW + px) * 3;
      rgb8Sums[off] = sR;
      rgb8Sums[off + 1] = sG;
      rgb8Sums[off + 2] = sB;
    }
  }

  return {
    mode: "raytrace_tile_v1",
    scenePreset,
    width,
    height,
    tileX,
    tileY,
    tileW,
    tileH,
    passIndex,
    samplesPerPixel: spp,
    rgb8Sums,
    samplesDone: tileW * tileH * spp,
  };
}

const tiles = [];
let samplesDone = 0;
for (let unitIndex = 0; unitIndex < units; unitIndex += 1) {
  const ordinal = shardOffset + unitIndex;
  const tile = renderTileForOrdinal(ordinal);
  if (!tile) {
    continue;
  }
  tiles.push(tile);
  samplesDone += Number(tile.samplesDone) || 0;
}

if (tiles.length === 1) {
  return {
    ...tiles[0],
    shardsDone: 1,
    samplesDone,
  };
}

return {
  mode: "raytrace_tiles_v1",
  scenePreset,
  width,
  height,
  tiles,
  shardsDone: tiles.length,
  samplesDone,
};`;
      }

      function getToken() {
        return (clientTokenEl.value || "").trim();
      }

      function setAuthStatus(text, cls) {
        authStatusEl.textContent = text;
        authStatusEl.className = cls || "";
      }

      async function apiFetch(path, options = {}) {
        const token = getToken();
        if (!token) {
          throw new Error("Missing client token.");
        }

        const headers = {
          Authorization: `Bearer ${token}`,
          ...(options.headers || {}),
        };

        const response = await fetch(path, {
          ...options,
          headers,
        });

        let data = null;
        try {
          data = await response.json();
        } catch (_err) {
          data = { error: `Non-JSON response (${response.status})` };
        }

        if (!response.ok) {
          throw new Error(data.error || `Request failed (${response.status})`);
        }

        return data;
      }

      async function pauseShardedJob(jobId) {
        if (!jobId) {
          return false;
        }
        try {
          await apiFetch(withBase(`/api/jobs/${encodeURIComponent(jobId)}/pause`), {
            method: "POST",
          });
          return true;
        } catch (_err) {
          return false;
        }
      }

      async function resumeShardedJob(jobId) {
        if (!jobId) {
          return false;
        }
        try {
          await apiFetch(withBase(`/api/jobs/${encodeURIComponent(jobId)}/resume`), {
            method: "POST",
          });
          return true;
        } catch (_err) {
          return false;
        }
      }

      function formatResult(value) {
        if (value === null || value === undefined) {
          return "-";
        }
        if (typeof value === "object" && value !== null && !Array.isArray(value)) {
          const isRunJsEnvelope =
            Object.prototype.hasOwnProperty.call(value, "exitCode") &&
            Object.prototype.hasOwnProperty.call(value, "output");
          if (isRunJsEnvelope) {
            const lines = [];
            lines.push(`ok: ${value.ok === true}`);
            lines.push(`exitCode: ${value.exitCode}`);
            if (typeof value.durationMs === "number") {
              lines.push(`durationMs: ${value.durationMs}`);
            }
            if (value.returnType) {
              lines.push(`returnType: ${value.returnType}`);
            }
            if (value.argsType) {
              lines.push(`argsType: ${value.argsType}`);
            }
            if (value.output && typeof value.output.bytes === "number") {
              lines.push(`outputBytes: ${value.output.bytes}`);
            }
            if (value.output && value.output.truncated === true) {
              lines.push("outputTruncated: true");
            }
            if (value.output && typeof value.output.text === "string" && value.output.text.length > 0) {
              lines.push("");
              lines.push("output:");
              lines.push(value.output.text);
            }
            if (Array.isArray(value.logs) && value.logs.length > 0) {
              lines.push("");
              lines.push("logs:");
              lines.push(value.logs.join("\n"));
            }
            if (Object.prototype.hasOwnProperty.call(value, "returnValue")) {
              lines.push("");
              lines.push("returnValue:");
              try {
                lines.push(JSON.stringify(value.returnValue, null, 2));
              } catch (_err) {
                lines.push("[unserializable returnValue]");
              }
            }
            if (value.error && value.error.message) {
              lines.push("");
              lines.push(`error: ${value.error.message}`);
              if (value.error.stack) {
                lines.push(value.error.stack);
              }
            }
            if (Array.isArray(value.notes) && value.notes.length > 0) {
              lines.push("");
              lines.push("notes:");
              lines.push(value.notes.join("\n"));
            }
            if (value.stats && typeof value.stats === "object") {
              lines.push("");
              lines.push("stats:");
              try {
                lines.push(JSON.stringify(value.stats, null, 2));
              } catch (_err) {
                lines.push("[unserializable stats]");
              }
            }
            return lines.join("\n");
          }
        }
        if (typeof value === "string") {
          return value;
        }
        try {
          return JSON.stringify(value, null, 2);
        } catch (_err) {
          return "[unserializable result]";
        }
      }

      function setStatus(status) {
        statusEl.textContent = status;
      }

      function setBusy(isBusy) {
        submitAddBtn.disabled = isBusy;
        submitScriptBtn.disabled = isBusy;
        startRaytraceBtnEl.disabled = isBusy;
        if (!stopAllInFlight) {
          stopAllJobsBtnEl.disabled = false;
        }
      }

      function detectExecutionModelFromInputs() {
        const hasTotalUnits = shardTotalUnitsEl.value.trim().length > 0;
        const hasUnitsPerShard = shardUnitsPerShardEl.value.trim().length > 0;
        if (hasTotalUnits && hasUnitsPerShard) {
          return "sharded";
        }
        if (!hasTotalUnits && !hasUnitsPerShard) {
          return "single";
        }
        return "invalid";
      }

      function getConnectedWorkerCount() {
        const workerCount = Number(workerCountEl.textContent);
        if (!Number.isInteger(workerCount) || workerCount < 0) {
          return null;
        }
        return workerCount;
      }

      function computeShardSafety(totalUnits, workerCount) {
        const effectiveWorkers = Math.max(workerCount || 2, 2);
        const maxShardsAllowed = Math.max(1, Math.min(SHARD_ABSOLUTE_MAX, effectiveWorkers * SHARD_MAX_PER_WORKER));
        const recommendedUnits = Math.max(SHARD_MIN_UNITS, Math.ceil(totalUnits / maxShardsAllowed));
        return { maxShardsAllowed, recommendedUnits };
      }

      function autoTuneShardInputs() {
        if (detectExecutionModelFromInputs() !== "sharded") {
          return null;
        }
        const totalUnits = Number(shardTotalUnitsEl.value);
        if (!Number.isInteger(totalUnits) || totalUnits <= 0) {
          return null;
        }
        const workerCount = getConnectedWorkerCount();
        if (workerCount !== null && workerCount < 2) {
          return {
            changed: false,
            workerCount,
            skippedForSingleFallback: true,
          };
        }
        const safety = computeShardSafety(totalUnits, workerCount);
        const currentUnits = Number(shardUnitsPerShardEl.value);
        if (!Number.isInteger(currentUnits) || currentUnits <= 0) {
          return null;
        }
        const finalUnitsPerShard = currentUnits;
        const resultingShards = Math.ceil(totalUnits / Math.max(finalUnitsPerShard, 1));
        return {
          changed: false,
          workerCount,
          totalUnits,
          unitsPerShard: finalUnitsPerShard,
          resultingShards,
          maxShardsAllowed: safety.maxShardsAllowed,
        };
      }

      function refreshReducerUi() {
        if (shardReducerEl.disabled) {
          shardSumFieldsEl.disabled = true;
          shardSumFieldsEl.placeholder = "sum fields disabled in single mode";
          return;
        }
        const isSum = shardReducerEl.value === "sum";
        shardSumFieldsEl.disabled = !isSum;
        if (isSum) {
          shardSumFieldsEl.placeholder = "e.g. hits,samples";
        } else if (shardReducerEl.value === "collect") {
          shardSumFieldsEl.placeholder = "not used for COLLECT";
        } else if (shardReducerEl.value === "min") {
          shardSumFieldsEl.placeholder = "not used for MIN (server uses field 'value')";
        } else {
          shardSumFieldsEl.placeholder = "not used for MAX (server uses field 'value')";
        }
      }

      function refreshAutoModeUi() {
        const model = detectExecutionModelFromInputs();
        const workerCount = getConnectedWorkerCount();
        if (model === "single") {
          autoModeHintEl.textContent = "Mode: auto single (default)";
          autoModeHintEl.className = "hint mono";
          shardReducerEl.disabled = true;
          refreshReducerUi();
          return;
        }
        if (model === "sharded") {
          if (workerCount !== null && workerCount < 2) {
            autoModeHintEl.textContent =
              "Mode: auto sharded requested, but server will run single until at least 2 workers are connected";
            autoModeHintEl.className = "hint mono warn-text";
          } else {
            const tuneInfo = autoTuneShardInputs();
            const tunedMessage =
              tuneInfo && Number.isInteger(tuneInfo.resultingShards)
                ? `Mode: auto sharded (cluster fan-out enabled, ${tuneInfo.resultingShards} shard(s))`
                : "Mode: auto sharded (cluster fan-out enabled)";
            autoModeHintEl.textContent = tunedMessage;
            autoModeHintEl.className = "hint mono ok";
          }
          shardReducerEl.disabled = false;
          refreshReducerUi();
          return;
        }
        autoModeHintEl.textContent = "Mode: invalid shard setup (set both shard fields or clear both)";
        autoModeHintEl.className = "hint mono warn-text";
        shardReducerEl.disabled = false;
        refreshReducerUi();
      }

      function clearInviteQr() {
        inviteQrEl.src = "";
        inviteQrEl.style.display = "none";
        downloadQrLinkEl.href = "";
        downloadQrLinkEl.style.display = "none";
      }

      function setInviteQr(dataUrl) {
        if (!dataUrl) {
          clearInviteQr();
          return;
        }
        inviteQrEl.src = dataUrl;
        inviteQrEl.style.display = "block";
        downloadQrLinkEl.href = dataUrl;
        downloadQrLinkEl.style.display = "inline-block";
      }

      function persistToken() {
        const token = getToken();
        if (!token) {
          localStorage.removeItem(TOKEN_KEY);
          setAuthStatus("missing token", "warn-text");
          return;
        }
        localStorage.setItem(TOKEN_KEY, token);
        setAuthStatus("saved", "ok");
      }

      async function checkAuth() {
        const token = getToken();
        if (!token) {
          setAuthStatus("missing token", "warn-text");
          return false;
        }

        try {
          await apiFetch(withBase("/api/auth/check"));
          setAuthStatus("authenticated", "ok");
          return true;
        } catch (err) {
          setAuthStatus(err.message, "err");
          return false;
        }
      }

      async function fetchWorkerCount() {
        try {
          const data = await apiFetch(withBase("/api/workers"));
          workerCountEl.textContent = String(data.count);
        } catch (_err) {
          workerCountEl.textContent = "-";
        }
        refreshAutoModeUi();
      }

      async function pollJob(jobId) {
        try {
          const data = await apiFetch(withBase(`/api/jobs/${jobId}`));
          setStatus(data.status);
          taskTypeEl.textContent = data.task && data.task.op ? data.task.op : "-";
          executionModelEl.textContent = data.executionModel || (data.task && data.task.executionModel) || "-";
          resultEl.textContent = formatResult(data.result);
          errorEl.textContent = data.error == null ? "-" : data.error;

          if (data.status === "done" || data.status === "failed") {
            removeSceneJobById(jobId);
            if (currentJobId === jobId && activeRaytraceSceneKey && raytraceJobsByScene[activeRaytraceSceneKey] === jobId) {
              activeRaytraceSceneKey = null;
            }
            clearInterval(pollTimer);
            pollTimer = null;
            setBusy(false);
          }
        } catch (err) {
          errorEl.textContent = err.message;
          setBusy(false);
        }
      }

      async function submitAndPoll(path, body) {
        setBusy(true);
        errorEl.textContent = "-";
        resultEl.textContent = "-";
        taskTypeEl.textContent = "-";
        executionModelEl.textContent = "-";
        setStatus("queued");

        try {
          const data = await apiFetch(withBase(path), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });

          currentJobId = data.jobId;
          jobIdEl.textContent = currentJobId;
          setStatus(data.status);
          updateRaytraceViewerLink();

          if (pollTimer) {
            clearInterval(pollTimer);
          }
          pollTimer = setInterval(() => {
            pollJob(currentJobId);
          }, 800);
          pollJob(currentJobId);
          return data;
        } catch (err) {
          setStatus("failed");
          errorEl.textContent = err.message;
          setBusy(false);
          return null;
        }
      }

      saveTokenBtn.addEventListener("click", async () => {
        persistToken();
        await checkAuth();
        if (workersTimer) {
          clearInterval(workersTimer);
        }
        workersTimer = setInterval(fetchWorkerCount, 2500);
        fetchWorkerCount();
      });

      generateInviteBtn.addEventListener("click", async () => {
        phraseCodeEl.value = "";
        phraseInviteUrlEl.value = "";
        shortInviteUrlEl.value = "";
        inviteUrlEl.value = "";
        clearInviteQr();
        try {
          const ttlSec = Number(inviteTtlEl.value);
          const invite = await apiFetch(withBase("/api/invites/worker"), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ttlSec }),
          });
          phraseCodeEl.value = invite.phraseCode || "(phrase unavailable)";
          phraseInviteUrlEl.value = invite.phraseInviteUrl || "(phrase URL unavailable)";
          shortInviteUrlEl.value = invite.shortInviteUrl || "(short URL unavailable)";
          inviteUrlEl.value = invite.inviteUrl;
          setInviteQr(invite.inviteQrDataUrl);
          if (navigator.clipboard) {
            const clipboardUrl = invite.phraseInviteUrl || invite.shortInviteUrl || invite.inviteUrl;
            if (clipboardUrl) {
              navigator.clipboard.writeText(clipboardUrl).catch(() => {});
            }
          }
        } catch (err) {
          phraseCodeEl.value = "";
          phraseInviteUrlEl.value = "";
          shortInviteUrlEl.value = "";
          clearInviteQr();
          inviteUrlEl.value = `Error: ${err.message}`;
        }
      });

      addJobForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const a = Number(inputA.value);
        const b = Number(inputB.value);
        await submitAndPoll("/api/jobs", { a, b });
      });

      startRaytraceBtnEl.addEventListener("click", async () => {
        const workerCount = getConnectedWorkerCount();
        if (workerCount !== null && workerCount < 2) {
          errorEl.textContent = "Live raytrace needs at least 2 connected workers.";
          return;
        }

        const settings = getRaytraceSettings();
        const estimatedTilePayloadBytes = estimateRaytraceTilePayloadBytes(settings);
        const safeBudgetBytes = Math.max(4096, Math.floor(publicMaxResultBytes * 0.9));
        if (estimatedTilePayloadBytes > safeBudgetBytes) {
          errorEl.textContent =
            `Raytrace tile payload is too large for current result limit (${safeBudgetBytes} bytes). ` +
            `Reduce tile size/samples, or increase CUSTOM_JOB_MAX_RESULT_BYTES on the server.`;
          raytraceHintEl.textContent =
            `Estimated tile payload ${estimatedTilePayloadBytes} bytes exceeds safe budget ${safeBudgetBytes} bytes.`;
          raytraceHintEl.className = "hint mono warn-text";
          return;
        }
        const sceneKey = sceneKeyFromSettings(settings);
        const existingJobId = raytraceJobsByScene[sceneKey];
        if (existingJobId) {
          const resumed = await resumeShardedJob(existingJobId);
          if (resumed) {
            currentJobId = existingJobId;
            jobIdEl.textContent = currentJobId;
            setStatus("running");
            activeRaytraceSceneKey = sceneKey;
            updateRaytraceViewerLink();
            if (pollTimer) {
              clearInterval(pollTimer);
            }
            pollTimer = setInterval(() => {
              pollJob(currentJobId);
            }, 800);
            pollJob(currentJobId);
            const viewerUrl = raytraceViewerUrl(existingJobId);
            window.open(viewerUrl, "_blank", "noopener");
            raytraceHintEl.textContent = "Resumed existing scene job from previous detail state.";
            raytraceHintEl.className = "hint mono ok";
            return;
          }
          delete raytraceJobsByScene[sceneKey];
          saveRaytraceSceneJobs();
        }

        const tilesX = Math.ceil(settings.width / settings.tileSize);
        const tilesY = Math.ceil(settings.height / settings.tileSize);
        const totalShards = Math.max(1, tilesX * tilesY * settings.passes);
        const effectiveWorkers = Math.max(2, workerCount || 0);
        const unitsPerShard = 1;
        const plannedShardCount = Math.ceil(totalShards / unitsPerShard);
        const payload = {
          code: buildRaytraceScript(),
          args: settings,
          executionModel: "sharded",
          shardConfig: {
            totalUnits: totalShards,
            unitsPerShard,
          },
          reducer: {
            type: "sum",
            fields: ["*"],
          },
          timeoutMs: 0,
        };

        const created = await submitAndPoll("/api/jobs/run-js", payload);
        if (!created || !created.jobId) {
          return;
        }
        raytraceHintEl.textContent = `Raytrace planned with ${plannedShardCount} shard job(s) across ${effectiveWorkers} worker(s).`;
        raytraceHintEl.className = "hint mono ok";
        activeRaytraceSceneKey = sceneKey;
        rememberSceneJob(sceneKey, created.jobId);
        const viewerUrl = raytraceViewerUrl(created.jobId);
        window.open(viewerUrl, "_blank", "noopener");
      });

      stopAllJobsBtnEl.addEventListener("click", async () => {
        if (stopAllInFlight) {
          return;
        }
        stopAllInFlight = true;
        stopAllJobsBtnEl.disabled = true;
        try {
          if (pollTimer) {
            clearInterval(pollTimer);
            pollTimer = null;
          }
          setStatus("stopping");
          const stopped = await apiFetch(withBase("/api/jobs/stop-all"), {
            method: "POST",
          });
          currentJobId = null;
          activeRaytraceSceneKey = null;
          raytraceJobsByScene = {};
          saveRaytraceSceneJobs();
          jobIdEl.textContent = "-";
          setStatus("idle");
          updateRaytraceViewerLink();
          raytraceHintEl.textContent = `Stopped ${Number(stopped.stopped || 0)} active job(s).`;
          raytraceHintEl.className = "hint mono ok";
          setBusy(false);
        } catch (err) {
          errorEl.textContent = err.message;
        } finally {
          stopAllInFlight = false;
          stopAllJobsBtnEl.disabled = false;
        }
      });

      rayScenePresetEl.addEventListener("change", async () => {
        const newSettings = getRaytraceSettings();
        const newSceneKey = sceneKeyFromSettings(newSettings);
        if (activeRaytraceSceneKey && activeRaytraceSceneKey !== newSceneKey) {
          const oldJobId = raytraceJobsByScene[activeRaytraceSceneKey];
          if (oldJobId) {
            const paused = await pauseShardedJob(oldJobId);
            if (paused) {
              raytraceHintEl.textContent = "Paused previous scene job.";
              raytraceHintEl.className = "hint mono warn-text";
            }
          }
        }

        const resumeJobId = raytraceJobsByScene[newSceneKey];
        if (!resumeJobId) {
          activeRaytraceSceneKey = newSceneKey;
          raytraceHintEl.textContent = "No saved job for this scene. Start a new live raytrace.";
          raytraceHintEl.className = "hint mono";
          return;
        }

        const resumed = await resumeShardedJob(resumeJobId);
        if (!resumed) {
          delete raytraceJobsByScene[newSceneKey];
          saveRaytraceSceneJobs();
          activeRaytraceSceneKey = newSceneKey;
          raytraceHintEl.textContent = "Saved scene job was unavailable. Start a new live raytrace.";
          raytraceHintEl.className = "hint mono warn-text";
          return;
        }

        activeRaytraceSceneKey = newSceneKey;
        currentJobId = resumeJobId;
        jobIdEl.textContent = currentJobId;
        updateRaytraceViewerLink();
        setStatus("running");
        if (pollTimer) {
          clearInterval(pollTimer);
        }
        pollTimer = setInterval(() => {
          pollJob(currentJobId);
        }, 800);
        pollJob(currentJobId);
        const viewerUrl = raytraceViewerUrl(resumeJobId);
        window.open(viewerUrl, "_blank", "noopener");
        raytraceHintEl.textContent = "Resumed saved scene job and continued from prior detail.";
        raytraceHintEl.className = "hint mono ok";
      });

      submitScriptBtn.addEventListener("click", async () => {
        const code = scriptCodeEl.value;
        if (!code.trim()) {
          errorEl.textContent = "Script code is required.";
          return;
        }

        const executionModel = detectExecutionModelFromInputs();
        if (executionModel === "invalid") {
          errorEl.textContent = "Set both shard fields for sharded mode, or leave both empty for single mode.";
          return;
        }
        const referencesBrain = /\b__BRAIN__\b/.test(code);
        if (executionModel === "single" && referencesBrain) {
          errorEl.textContent =
            "This script references __BRAIN__. Fill both shard fields to run in sharded mode, or remove __BRAIN__ usage.";
          return;
        }
        const body = { code, executionModel };
        const rawArgs = scriptArgsEl.value.trim();
        if (rawArgs) {
          try {
            body.args = JSON.parse(rawArgs);
          } catch (_err) {
            errorEl.textContent = "Args must be valid JSON.";
            return;
          }
        }

        if (executionModel === "sharded") {
          const totalUnits = Number(shardTotalUnitsEl.value);
          const unitsPerShard = Number(shardUnitsPerShardEl.value);
          if (!Number.isInteger(totalUnits) || totalUnits <= 0) {
            errorEl.textContent = "total units must be a positive integer.";
            return;
          }
          if (!Number.isInteger(unitsPerShard) || unitsPerShard <= 0) {
            errorEl.textContent = "units per shard must be a positive integer.";
            return;
          }
          body.shardConfig = { totalUnits, unitsPerShard };

          const reducerType = shardReducerEl.value;
          if (reducerType === "sum") {
            const fields = (shardSumFieldsEl.value || "hits,samples")
              .split(",")
              .map((v) => v.trim())
              .filter(Boolean);
            if (fields.length === 0) {
              errorEl.textContent = "sum reducer needs at least one field.";
              return;
            }
            body.reducer = { type: "sum", fields };
          } else if (reducerType === "collect") {
            body.reducer = { type: "collect" };
          } else {
            body.reducer = { type: reducerType, field: "value" };
          }
        }

        if (scriptTimeoutMsEl.value.trim()) {
          const timeoutMs = Number(scriptTimeoutMsEl.value);
          if (!Number.isSafeInteger(timeoutMs) || timeoutMs < 0) {
            errorEl.textContent = "Timeout must be a non-negative safe integer (0 = no timeout).";
            return;
          }
          body.timeoutMs = timeoutMs;
        }
        await submitAndPoll("/api/jobs/run-js", body);
      });

      shardTotalUnitsEl.addEventListener("input", refreshAutoModeUi);
      shardUnitsPerShardEl.addEventListener("input", refreshAutoModeUi);
      shardReducerEl.addEventListener("change", refreshReducerUi);
      toggleParallelGuideBtnEl.addEventListener("click", () => {
        const isNowHidden = parallelGuidePanelEl.classList.toggle("hidden");
        toggleParallelGuideBtnEl.textContent = isNowHidden ? "Show Parallel Guide" : "Hide Parallel Guide";
      });

      scriptFileBtnEl.addEventListener("click", () => {
        scriptFileEl.click();
      });

      scriptFileEl.addEventListener("change", () => {
        const file = scriptFileEl.files && scriptFileEl.files[0];
        if (!file) {
          scriptFileNameEl.textContent = "No file chosen";
          return;
        }
        scriptFileNameEl.textContent = file.name;
        const reader = new FileReader();
        reader.onload = () => {
          scriptCodeEl.value = String(reader.result || "");
        };
        reader.readAsText(file);
      });

      const savedToken = localStorage.getItem(TOKEN_KEY);
      fetch(withBase("/api/public-config"), { cache: "no-store" })
        .then((res) => (res.ok ? res.json() : null))
        .then((cfg) => {
          const configuredMax =
            cfg &&
            cfg.customJobLimits &&
            Number.isInteger(cfg.customJobLimits.maxResultBytes) &&
            cfg.customJobLimits.maxResultBytes > 0
              ? cfg.customJobLimits.maxResultBytes
              : null;
          if (configuredMax) {
            publicMaxResultBytes = configuredMax;
          }
        })
        .catch(() => {});
      if (savedToken) {
        clientTokenEl.value = savedToken;
        checkAuth().then((ok) => {
          if (ok) {
            fetchWorkerCount();
            workersTimer = setInterval(fetchWorkerCount, 2500);
          }
        });
      }
      openGuidePageLinkEl.href = withBase("/parallel-guide.html");
      openMetricsPageLinkEl.href = withBase("/metrics.html");
      openRaytraceViewerLinkEl.href = raytraceViewerUrl(null);
      activeRaytraceSceneKey = sceneKeyFromSettings(getRaytraceSettings());
      updateRaytraceViewerLink();
      refreshAutoModeUi();
      refreshReducerUi();
    </script>
  </body>
</html>
