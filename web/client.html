<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cluster Secure Client</title>
    <style>
      :root {
        --bg: #0a1128;
        --card: #1b263b;
        --text: #f8f9fa;
        --muted: #c2cde3;
        --ok: #52b788;
        --warn: #ffb703;
        --err: #ef476f;
        --accent: #00b4d8;
      }
      body {
        margin: 0;
        font-family: "Segoe UI", Tahoma, sans-serif;
        color: var(--text);
        background: radial-gradient(circle at 20% 10%, #1f3f7a, var(--bg) 50%);
        min-height: 100vh;
      }
      .wrap {
        max-width: 860px;
        margin: 2rem auto;
        padding: 1rem;
      }
      .card {
        background: color-mix(in srgb, var(--card) 90%, black);
        border: 1px solid #35507a;
        border-radius: 12px;
        padding: 1rem;
        margin-bottom: 1rem;
      }
      h1 {
        margin: 0 0 0.3rem 0;
        font-size: 1.5rem;
      }
      p {
        margin: 0.35rem 0;
        color: var(--muted);
      }
      .row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 0.5rem;
      }
      .stack {
        display: grid;
        gap: 0.6rem;
      }
      form {
        display: grid;
        grid-template-columns: 1fr 1fr auto;
        gap: 0.6rem;
      }
      .custom-form {
        display: grid;
        gap: 0.6rem;
      }
      .script-options-row {
        display: grid;
        grid-template-columns: 1fr 180px auto;
        gap: 0.6rem;
      }
      .file-picker {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 0.6rem;
        align-items: center;
      }
      .file-picker input[type="file"] {
        display: none;
      }
      .file-name {
        color: var(--muted);
        overflow-wrap: anywhere;
      }
      input,
      button,
      textarea {
        border-radius: 8px;
        border: 1px solid #4c6898;
        padding: 0.6rem 0.8rem;
        font-size: 0.95rem;
      }
      input,
      textarea {
        background: #0e1a35;
        color: var(--text);
      }
      button {
        background: var(--accent);
        color: #001219;
        font-weight: 700;
        cursor: pointer;
      }
      button.secondary {
        background: #8ecae6;
      }
      button.file-btn {
        border-color: #7fc6dd;
        background: linear-gradient(180deg, #9dd8eb, #78bfd8);
      }
      button.warn {
        background: var(--warn);
      }
      button:disabled {
        opacity: 0.6;
        cursor: default;
      }
      .mono {
        font-family: Consolas, Menlo, monospace;
      }
      .line {
        margin: 0.45rem 0;
      }
      .ok {
        color: var(--ok);
      }
      .err {
        color: var(--err);
      }
      .warn-text {
        color: var(--warn);
      }
      textarea {
        resize: vertical;
        min-height: 70px;
      }
      #scriptCode {
        min-height: 160px;
      }
      .qr-panel {
        display: flex;
        gap: 0.8rem;
        align-items: center;
        flex-wrap: wrap;
      }
      #inviteQr {
        display: none;
        width: 220px;
        height: 220px;
        background: #fff;
        border-radius: 8px;
        padding: 6px;
      }
      #downloadQrLink {
        display: none;
        color: var(--text);
      }
      #result {
        display: block;
        white-space: pre-wrap;
        word-break: break-word;
      }
      @media (max-width: 780px) {
        form,
        .row,
        .script-options-row,
        .file-picker {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card stack">
        <h1>Cluster Secure Client</h1>
        <p>Use your client token to submit jobs and generate worker invite links.</p>
        <div class="row">
          <input id="clientToken" placeholder="Client token or mnemonic phrase (required)" />
          <button id="saveTokenBtn" class="secondary" type="button">Save Token</button>
        </div>
        <p class="line">Auth status: <strong id="authStatus" class="warn-text">not checked</strong></p>
        <p class="line">Workers connected: <strong id="workerCount">0</strong></p>
      </div>

      <div class="card stack">
        <strong>Generate Worker Invite</strong>
        <div class="row">
          <input id="inviteTtl" type="number" min="60" max="86400" value="3600" placeholder="TTL seconds" />
          <button id="generateInviteBtn" type="button">Generate Invite URL</button>
        </div>
        <textarea id="phraseCode" class="mono" readonly placeholder="Worker phrase code (type words separated by spaces)"></textarea>
        <textarea id="phraseInviteUrl" class="mono" readonly placeholder="Worker phrase URL"></textarea>
        <textarea id="shortInviteUrl" class="mono" readonly placeholder="Short invite URL (easy to type)"></textarea>
        <textarea id="inviteUrl" class="mono" readonly placeholder="Invite URL will appear here"></textarea>
        <div class="qr-panel">
          <img id="inviteQr" alt="Worker invite QR code" />
          <a id="downloadQrLink" class="mono" download="worker-invite-qr.png">Download QR PNG</a>
        </div>
      </div>

      <div class="card stack">
        <strong>Submit Job (a + b)</strong>
        <form id="addJobForm">
          <input id="inputA" name="a" type="number" step="1" required placeholder="a (integer)" />
          <input id="inputB" name="b" type="number" step="1" required placeholder="b (integer)" />
          <button id="submitAddBtn" type="submit">Submit</button>
        </form>
      </div>

      <div class="card stack">
        <strong>Run Your Own JS (Signed)</strong>
        <div class="custom-form">
          <div class="file-picker">
            <input id="scriptFile" type="file" accept=".js,text/javascript" />
            <button id="scriptFileBtn" class="secondary file-btn" type="button">Choose JS File</button>
            <span id="scriptFileName" class="mono file-name">No file chosen</span>
          </div>
          <textarea
            id="scriptCode"
            class="mono"
            placeholder="Example:
const samples = Number(args.samples || 1_000_000);
let hits = 0;
for (let i = 0; i < samples; i += 1) {
  const x = Math.random();
  const y = Math.random();
  if (x * x + y * y <= 1) hits += 1;
}
const pi = 4 * hits / samples;
console.log('estimated pi:', pi);
return { samples, hits, pi };"
          ></textarea>
          <div class="script-options-row">
            <input id="scriptArgs" class="mono" placeholder='args JSON (optional), e.g. {"samples":10000000}' />
            <input id="scriptTimeoutMs" type="number" min="200" step="100" placeholder="run timeout ms (optional)" />
            <button id="submitScriptBtn" type="button">Run Script</button>
          </div>
        </div>
      </div>

      <div class="card">
        <p class="line">Job ID: <span class="mono" id="jobId">-</span></p>
        <p class="line">Task Type: <strong id="taskType">-</strong></p>
        <p class="line">Status: <strong id="status">idle</strong></p>
        <p class="line">Result: <span class="mono" id="result">-</span></p>
        <p class="line">Error: <span id="error">-</span></p>
      </div>
    </div>

    <script>
      const TOKEN_KEY = "cluster_client_token";
      const BASE_PATH = (() => {
        const path = window.location.pathname.replace(/\/+$/, "");
        if (path.endsWith("/client")) {
          return path.slice(0, -"/client".length);
        }
        return "";
      })();

      function withBase(path) {
        return `${BASE_PATH}${path}`;
      }

      const clientTokenEl = document.getElementById("clientToken");
      const saveTokenBtn = document.getElementById("saveTokenBtn");
      const authStatusEl = document.getElementById("authStatus");
      const workerCountEl = document.getElementById("workerCount");

      const inviteTtlEl = document.getElementById("inviteTtl");
      const generateInviteBtn = document.getElementById("generateInviteBtn");
      const phraseCodeEl = document.getElementById("phraseCode");
      const phraseInviteUrlEl = document.getElementById("phraseInviteUrl");
      const shortInviteUrlEl = document.getElementById("shortInviteUrl");
      const inviteUrlEl = document.getElementById("inviteUrl");
      const inviteQrEl = document.getElementById("inviteQr");
      const downloadQrLinkEl = document.getElementById("downloadQrLink");

      const addJobForm = document.getElementById("addJobForm");
      const inputA = document.getElementById("inputA");
      const inputB = document.getElementById("inputB");
      const submitAddBtn = document.getElementById("submitAddBtn");

      const scriptFileEl = document.getElementById("scriptFile");
      const scriptFileBtnEl = document.getElementById("scriptFileBtn");
      const scriptFileNameEl = document.getElementById("scriptFileName");
      const scriptCodeEl = document.getElementById("scriptCode");
      const scriptArgsEl = document.getElementById("scriptArgs");
      const scriptTimeoutMsEl = document.getElementById("scriptTimeoutMs");
      const submitScriptBtn = document.getElementById("submitScriptBtn");

      const taskTypeEl = document.getElementById("taskType");
      const jobIdEl = document.getElementById("jobId");
      const statusEl = document.getElementById("status");
      const resultEl = document.getElementById("result");
      const errorEl = document.getElementById("error");

      let currentJobId = null;
      let pollTimer = null;
      let workersTimer = null;

      function getToken() {
        return (clientTokenEl.value || "").trim();
      }

      function setAuthStatus(text, cls) {
        authStatusEl.textContent = text;
        authStatusEl.className = cls || "";
      }

      async function apiFetch(path, options = {}) {
        const token = getToken();
        if (!token) {
          throw new Error("Missing client token.");
        }

        const headers = {
          Authorization: `Bearer ${token}`,
          ...(options.headers || {}),
        };

        const response = await fetch(path, {
          ...options,
          headers,
        });

        let data = null;
        try {
          data = await response.json();
        } catch (_err) {
          data = { error: `Non-JSON response (${response.status})` };
        }

        if (!response.ok) {
          throw new Error(data.error || `Request failed (${response.status})`);
        }

        return data;
      }

      function formatResult(value) {
        if (value === null || value === undefined) {
          return "-";
        }
        if (typeof value === "object" && value !== null && !Array.isArray(value)) {
          const isRunJsEnvelope =
            Object.prototype.hasOwnProperty.call(value, "exitCode") &&
            Object.prototype.hasOwnProperty.call(value, "output");
          if (isRunJsEnvelope) {
            const lines = [];
            lines.push(`ok: ${value.ok === true}`);
            lines.push(`exitCode: ${value.exitCode}`);
            if (typeof value.durationMs === "number") {
              lines.push(`durationMs: ${value.durationMs}`);
            }
            if (value.returnType) {
              lines.push(`returnType: ${value.returnType}`);
            }
            if (value.argsType) {
              lines.push(`argsType: ${value.argsType}`);
            }
            if (value.output && typeof value.output.bytes === "number") {
              lines.push(`outputBytes: ${value.output.bytes}`);
            }
            if (value.output && value.output.truncated === true) {
              lines.push("outputTruncated: true");
            }
            if (value.output && typeof value.output.text === "string" && value.output.text.length > 0) {
              lines.push("");
              lines.push("output:");
              lines.push(value.output.text);
            }
            if (Array.isArray(value.logs) && value.logs.length > 0) {
              lines.push("");
              lines.push("logs:");
              lines.push(value.logs.join("\n"));
            }
            if (Object.prototype.hasOwnProperty.call(value, "returnValue")) {
              lines.push("");
              lines.push("returnValue:");
              try {
                lines.push(JSON.stringify(value.returnValue, null, 2));
              } catch (_err) {
                lines.push("[unserializable returnValue]");
              }
            }
            if (value.error && value.error.message) {
              lines.push("");
              lines.push(`error: ${value.error.message}`);
              if (value.error.stack) {
                lines.push(value.error.stack);
              }
            }
            if (Array.isArray(value.notes) && value.notes.length > 0) {
              lines.push("");
              lines.push("notes:");
              lines.push(value.notes.join("\n"));
            }
            if (value.stats && typeof value.stats === "object") {
              lines.push("");
              lines.push("stats:");
              try {
                lines.push(JSON.stringify(value.stats, null, 2));
              } catch (_err) {
                lines.push("[unserializable stats]");
              }
            }
            return lines.join("\n");
          }
        }
        if (typeof value === "string") {
          return value;
        }
        try {
          return JSON.stringify(value, null, 2);
        } catch (_err) {
          return "[unserializable result]";
        }
      }

      function setStatus(status) {
        statusEl.textContent = status;
      }

      function setBusy(isBusy) {
        submitAddBtn.disabled = isBusy;
        submitScriptBtn.disabled = isBusy;
      }

      function clearInviteQr() {
        inviteQrEl.src = "";
        inviteQrEl.style.display = "none";
        downloadQrLinkEl.href = "";
        downloadQrLinkEl.style.display = "none";
      }

      function setInviteQr(dataUrl) {
        if (!dataUrl) {
          clearInviteQr();
          return;
        }
        inviteQrEl.src = dataUrl;
        inviteQrEl.style.display = "block";
        downloadQrLinkEl.href = dataUrl;
        downloadQrLinkEl.style.display = "inline-block";
      }

      function persistToken() {
        const token = getToken();
        if (!token) {
          localStorage.removeItem(TOKEN_KEY);
          setAuthStatus("missing token", "warn-text");
          return;
        }
        localStorage.setItem(TOKEN_KEY, token);
        setAuthStatus("saved", "ok");
      }

      async function checkAuth() {
        const token = getToken();
        if (!token) {
          setAuthStatus("missing token", "warn-text");
          return false;
        }

        try {
          await apiFetch(withBase("/api/auth/check"));
          setAuthStatus("authenticated", "ok");
          return true;
        } catch (err) {
          setAuthStatus(err.message, "err");
          return false;
        }
      }

      async function fetchWorkerCount() {
        try {
          const data = await apiFetch(withBase("/api/workers"));
          workerCountEl.textContent = String(data.count);
        } catch (_err) {
          workerCountEl.textContent = "-";
        }
      }

      async function pollJob(jobId) {
        try {
          const data = await apiFetch(withBase(`/api/jobs/${jobId}`));
          setStatus(data.status);
          taskTypeEl.textContent = data.task && data.task.op ? data.task.op : "-";
          resultEl.textContent = formatResult(data.result);
          errorEl.textContent = data.error == null ? "-" : data.error;

          if (data.status === "done" || data.status === "failed") {
            clearInterval(pollTimer);
            pollTimer = null;
            setBusy(false);
          }
        } catch (err) {
          errorEl.textContent = err.message;
          setBusy(false);
        }
      }

      async function submitAndPoll(path, body) {
        setBusy(true);
        errorEl.textContent = "-";
        resultEl.textContent = "-";
        taskTypeEl.textContent = "-";
        setStatus("queued");

        try {
          const data = await apiFetch(withBase(path), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });

          currentJobId = data.jobId;
          jobIdEl.textContent = currentJobId;
          setStatus(data.status);

          if (pollTimer) {
            clearInterval(pollTimer);
          }
          pollTimer = setInterval(() => {
            pollJob(currentJobId);
          }, 800);
          pollJob(currentJobId);
        } catch (err) {
          setStatus("failed");
          errorEl.textContent = err.message;
          setBusy(false);
        }
      }

      saveTokenBtn.addEventListener("click", async () => {
        persistToken();
        await checkAuth();
        if (workersTimer) {
          clearInterval(workersTimer);
        }
        workersTimer = setInterval(fetchWorkerCount, 2500);
        fetchWorkerCount();
      });

      generateInviteBtn.addEventListener("click", async () => {
        phraseCodeEl.value = "";
        phraseInviteUrlEl.value = "";
        shortInviteUrlEl.value = "";
        inviteUrlEl.value = "";
        clearInviteQr();
        try {
          const ttlSec = Number(inviteTtlEl.value);
          const invite = await apiFetch(withBase("/api/invites/worker"), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ttlSec }),
          });
          phraseCodeEl.value = invite.phraseCode || "(phrase unavailable)";
          phraseInviteUrlEl.value = invite.phraseInviteUrl || "(phrase URL unavailable)";
          shortInviteUrlEl.value = invite.shortInviteUrl || "(short URL unavailable)";
          inviteUrlEl.value = invite.inviteUrl;
          setInviteQr(invite.inviteQrDataUrl);
          if (navigator.clipboard) {
            const clipboardUrl = invite.phraseInviteUrl || invite.shortInviteUrl || invite.inviteUrl;
            if (clipboardUrl) {
              navigator.clipboard.writeText(clipboardUrl).catch(() => {});
            }
          }
        } catch (err) {
          phraseCodeEl.value = "";
          phraseInviteUrlEl.value = "";
          shortInviteUrlEl.value = "";
          clearInviteQr();
          inviteUrlEl.value = `Error: ${err.message}`;
        }
      });

      addJobForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const a = Number(inputA.value);
        const b = Number(inputB.value);
        await submitAndPoll("/api/jobs", { a, b });
      });

      submitScriptBtn.addEventListener("click", async () => {
        const code = scriptCodeEl.value;
        if (!code.trim()) {
          errorEl.textContent = "Script code is required.";
          return;
        }

        const body = { code };
        const rawArgs = scriptArgsEl.value.trim();
        if (rawArgs) {
          try {
            body.args = JSON.parse(rawArgs);
          } catch (_err) {
            errorEl.textContent = "Args must be valid JSON.";
            return;
          }
        }
        if (scriptTimeoutMsEl.value.trim()) {
          const timeoutMs = Number(scriptTimeoutMsEl.value);
          if (!Number.isFinite(timeoutMs) || timeoutMs <= 0) {
            errorEl.textContent = "Timeout must be a positive number.";
            return;
          }
          body.timeoutMs = timeoutMs;
        }
        await submitAndPoll("/api/jobs/run-js", body);
      });

      scriptFileBtnEl.addEventListener("click", () => {
        scriptFileEl.click();
      });

      scriptFileEl.addEventListener("change", () => {
        const file = scriptFileEl.files && scriptFileEl.files[0];
        if (!file) {
          scriptFileNameEl.textContent = "No file chosen";
          return;
        }
        scriptFileNameEl.textContent = file.name;
        const reader = new FileReader();
        reader.onload = () => {
          scriptCodeEl.value = String(reader.result || "");
        };
        reader.readAsText(file);
      });

      const savedToken = localStorage.getItem(TOKEN_KEY);
      if (savedToken) {
        clientTokenEl.value = savedToken;
        checkAuth().then((ok) => {
          if (ok) {
            fetchWorkerCount();
            workersTimer = setInterval(fetchWorkerCount, 2500);
          }
        });
      }
    </script>
  </body>
</html>
