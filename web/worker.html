<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cluster Worker</title>
    <style>
      :root {
        --bg: #102542;
        --card: #1f3b62;
        --text: #edf2f4;
        --muted: #c2d4e7;
        --ok: #06d6a0;
        --warn: #ffd166;
        --error: #ef476f;
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Segoe UI", Tahoma, sans-serif;
        background: linear-gradient(130deg, #0b1f37, var(--bg) 50%, #1d3557);
        color: var(--text);
      }
      .wrap {
        max-width: 760px;
        margin: 1.2rem auto;
        padding: 1rem;
      }
      .card {
        background: color-mix(in srgb, var(--card) 85%, black);
        border: 1px solid #45648d;
        border-radius: 12px;
        padding: 1rem;
        margin-bottom: 1rem;
      }
      h1 {
        margin: 0 0 0.4rem 0;
      }
      .pill {
        display: inline-block;
        padding: 0.2rem 0.6rem;
        border-radius: 999px;
        font-weight: 700;
      }
      .connected {
        background: color-mix(in srgb, var(--ok) 20%, transparent);
        color: var(--ok);
      }
      .connecting {
        background: color-mix(in srgb, var(--warn) 20%, transparent);
        color: var(--warn);
      }
      .disconnected {
        background: color-mix(in srgb, var(--error) 20%, transparent);
        color: var(--error);
      }
      .mono {
        font-family: Consolas, Menlo, monospace;
      }
      .err {
        color: var(--error);
      }
      button {
        border-radius: 8px;
        border: 1px solid #4c6898;
        padding: 0.45rem 0.7rem;
        font-size: 0.9rem;
        background: #7ec8e3;
        color: #001219;
        font-weight: 700;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.6;
        cursor: default;
      }
      #log {
        white-space: pre-wrap;
        background: #0e1e35;
        border-radius: 8px;
        padding: 0.75rem;
        max-height: 280px;
        overflow-y: auto;
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card">
        <h1>Volunteer Worker</h1>
        <p>
          Status:
          <span id="connState" class="pill connecting">connecting</span>
        </p>
        <p>Worker ID: <span class="mono" id="workerId"></span></p>
        <p>Current Job: <span class="mono" id="currentJob">idle</span></p>
        <p>Invite: <span id="inviteState" class="mono"></span></p>
        <p>
          Keep Awake:
          <span id="wakeState" class="pill connecting">checking</span>
          <button id="wakeBtn" type="button">Enable</button>
        </p>
        <p id="wakeHint" class="mono"></p>
        <p id="inviteError" class="err"></p>
      </div>

      <div class="card">
        <strong>Log</strong>
        <div id="log"></div>
      </div>
    </div>

    <script>
      const WORKER_ID_KEY = "cluster_worker_id";
      const MAX_RECONNECT_MS = 10_000;
      const HEARTBEAT_INTERVAL_MS = 20_000;
      const MAX_CLOCK_SKEW_MS = 30_000;
      const DEFAULT_MAX_RESULT_BYTES = 64 * 1024;
      const BASE_PATH = (() => {
        const path = window.location.pathname.replace(/\/+$/, "");
        if (path.endsWith("/worker")) {
          return path.slice(0, -"/worker".length);
        }
        return "";
      })();

      const EXECUTOR_SOURCE = `
const EXECUTOR_DONE_FLAG = "__cluster_exec_done__";
const MAX_LOG_LINES = 160;
const MAX_LOG_LINE_CHARS = 280;
const MAX_OUTPUT_CHARS = 28 * 1024;
const MAX_ERROR_CHARS = 6 * 1024;
const MAX_STACK_CHARS = 10 * 1024;
const MAX_RETURN_PREVIEW_CHARS = 4 * 1024;
const DEFAULT_RESULT_BUDGET_BYTES = 64 * 1024;

function utf8Bytes(input) {
  return new TextEncoder().encode(String(input)).length;
}

function valueType(value) {
  if (value === null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "array";
  }
  return typeof value;
}

function clampChars(input, maxChars) {
  const text = String(input);
  if (text.length <= maxChars) {
    return text;
  }
  return text.slice(0, Math.max(0, maxChars - 3)) + "...";
}

function safeJsonStringify(value) {
  try {
    return { ok: true, json: JSON.stringify(value) };
  } catch (_error) {
    return { ok: false, json: "" };
  }
}

function formatLogArg(arg) {
  if (typeof arg === "string") {
    return arg;
  }
  const asJson = safeJsonStringify(arg);
  if (asJson.ok && asJson.json !== undefined) {
    return asJson.json;
  }
  try {
    return String(arg);
  } catch (_error) {
    return "[unprintable]";
  }
}

function makeOutputEnvelope(rawOutput, wasTruncated) {
  return {
    text: rawOutput,
    truncated: Boolean(wasTruncated),
    bytes: utf8Bytes(rawOutput),
  };
}

function normalizeReturnValue(rawResult) {
  const serialized = safeJsonStringify(rawResult);
  if (!serialized.ok) {
    return {
      value: {
        nonSerializable: true,
        type: valueType(rawResult),
        preview: clampChars(formatLogArg(rawResult), MAX_RETURN_PREVIEW_CHARS),
      },
      returnType: valueType(rawResult),
      serializedBytes: null,
      normalized: false,
      note: "Result was not JSON-serializable.",
    };
  }

  if (serialized.json === undefined) {
    return {
      value: null,
      returnType: "undefined",
      serializedBytes: utf8Bytes("null"),
      normalized: true,
      note: "Script returned undefined.",
    };
  }

  const serializedBytes = utf8Bytes(serialized.json);
  if (serializedBytes > DEFAULT_RESULT_BUDGET_BYTES / 2) {
    return {
      value: {
        truncated: true,
        type: valueType(rawResult),
        totalSerializedBytes: serializedBytes,
        preview: clampChars(serialized.json, MAX_RETURN_PREVIEW_CHARS),
      },
      returnType: valueType(rawResult),
      serializedBytes,
      normalized: true,
      note: "Result was large and was summarized.",
    };
  }

  return {
    value: JSON.parse(serialized.json),
    returnType: valueType(rawResult),
    serializedBytes,
    normalized: true,
    note: null,
  };
}

function clampEnvelopeToBudget(envelope, budgetBytes) {
  const budget = Number.isFinite(Number(budgetBytes)) ? Math.max(4 * 1024, Number(budgetBytes)) : DEFAULT_RESULT_BUDGET_BYTES;

  function fits(payload) {
    const json = JSON.stringify(payload);
    if (json === undefined) {
      return false;
    }
    return utf8Bytes(json) <= budget;
  }

  if (fits(envelope)) {
    return envelope;
  }

  const next = { ...envelope };
  if (next.output && typeof next.output.text === "string" && next.output.text.length > 0) {
    next.output = makeOutputEnvelope(clampChars(next.output.text, Math.floor(next.output.text.length * 0.55)), true);
  }
  if (fits(next)) {
    return next;
  }

  next.logs = [];
  if (fits(next)) {
    return next;
  }

  if (next.error) {
    if (typeof next.error.stack === "string") {
      next.error.stack = clampChars(next.error.stack, 1024);
    }
    if (typeof next.error.message === "string") {
      next.error.message = clampChars(next.error.message, 512);
    }
  }
  if (fits(next)) {
    return next;
  }

  next.returnValue = {
    truncated: true,
    preview: clampChars(formatLogArg(next.returnValue), 1024),
  };
  next.notes = (Array.isArray(next.notes) ? next.notes : []).concat("Result trimmed to fit server size limit.");
  if (fits(next)) {
    return next;
  }

  return {
    ok: false,
    exitCode: 70,
    durationMs: Number(next.durationMs) || 0,
    returnType: "none",
    returnValue: null,
    argsType: next.argsType || "unknown",
    logs: [],
    output: makeOutputEnvelope("", false),
    error: {
      message: "Execution result exceeded transport budget.",
      stack: null,
    },
    notes: ["Result was aggressively trimmed due to size constraints."],
  };
}

self.onmessage = async (event) => {
  const startedAt = Date.now();
  const payload = event.data || {};
  const code = typeof payload.code === "string" ? payload.code : "";
  const args = payload.args;
  const resultBudgetBytes = payload.resultBudgetBytes;
  const notes = [];

  let outputChars = 0;
  let outputText = "";
  let outputTruncated = false;
  let droppedLogs = 0;
  const logs = [];

  function appendOutput(level, entries) {
    const rendered = entries.map((entry) => formatLogArg(entry)).join(" ");
    const line = "[" + level + "] " + clampChars(rendered, MAX_LOG_LINE_CHARS);
    if (logs.length >= MAX_LOG_LINES) {
      logs.shift();
      droppedLogs += 1;
    }
    logs.push(line);

    if (outputTruncated) {
      return;
    }
    const suffix = outputText.length === 0 ? line : "\\n" + line;
    if (outputChars + suffix.length > MAX_OUTPUT_CHARS) {
      const remaining = Math.max(0, MAX_OUTPUT_CHARS - outputChars);
      outputText += suffix.slice(0, remaining);
      outputChars = outputText.length;
      outputTruncated = true;
      return;
    }
    outputText += suffix;
    outputChars = outputText.length;
  }

  const capturedConsole = {
    log: (...entries) => appendOutput("log", entries),
    info: (...entries) => appendOutput("info", entries),
    warn: (...entries) => appendOutput("warn", entries),
    error: (...entries) => appendOutput("error", entries),
    debug: (...entries) => appendOutput("debug", entries),
  };
  capturedConsole.trace = (...entries) => {
    appendOutput("trace", entries);
  };

  const previousConsole = self.console;
  self.console = capturedConsole;

  let envelope = null;

  try {
    const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;
    const fn = new AsyncFunction("args", "console", '"use strict";\\n' + code);
    const rawResult = await fn(args, capturedConsole);
    const normalized = normalizeReturnValue(rawResult);
    if (normalized.note) {
      notes.push(normalized.note);
    }
    envelope = {
      ok: true,
      exitCode: 0,
      durationMs: Date.now() - startedAt,
      returnType: normalized.returnType,
      returnValue: normalized.value,
      argsType: valueType(args),
      logs,
      output: makeOutputEnvelope(outputText, outputTruncated),
      error: null,
      notes,
      stats: {
        droppedLogs,
        serializedReturnBytes: normalized.serializedBytes,
      },
    };
  } catch (error) {
    const message = error && error.message ? clampChars(error.message, MAX_ERROR_CHARS) : "Execution failed";
    const stack = error && error.stack ? clampChars(error.stack, MAX_STACK_CHARS) : null;
    envelope = {
      ok: false,
      exitCode: 1,
      durationMs: Date.now() - startedAt,
      returnType: "none",
      returnValue: null,
      argsType: valueType(args),
      logs,
      output: makeOutputEnvelope(outputText, outputTruncated),
      error: {
        message,
        stack,
      },
      notes,
      stats: {
        droppedLogs,
        serializedReturnBytes: null,
      },
    };
  } finally {
    self.console = previousConsole;
  }

  if (outputTruncated) {
    envelope.notes = (Array.isArray(envelope.notes) ? envelope.notes : []).concat("Console output was truncated.");
  }
  if (droppedLogs > 0) {
    envelope.notes = (Array.isArray(envelope.notes) ? envelope.notes : []).concat("Old log lines were dropped due to volume.");
  }

  const boundedEnvelope = clampEnvelopeToBudget(envelope, resultBudgetBytes);
  self.postMessage({
    [EXECUTOR_DONE_FLAG]: true,
    result: boundedEnvelope,
  });
};
`;

      function withBase(path) {
        return `${BASE_PATH}${path}`;
      }

      function randomSuffix() {
        return Math.random().toString(36).slice(2, 8);
      }

      function getWorkerId() {
        let workerId = localStorage.getItem(WORKER_ID_KEY);
        if (!workerId) {
          workerId = `worker-${randomSuffix()}`;
          localStorage.setItem(WORKER_ID_KEY, workerId);
        }
        return workerId;
      }

      function base64ToBytes(base64) {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i += 1) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
      }

      function base64UrlToBytes(base64url) {
        let base64 = String(base64url).replace(/-/g, "+").replace(/_/g, "/");
        while (base64.length % 4 !== 0) {
          base64 += "=";
        }
        return base64ToBytes(base64);
      }

      const connStateEl = document.getElementById("connState");
      const workerIdEl = document.getElementById("workerId");
      const currentJobEl = document.getElementById("currentJob");
      const inviteStateEl = document.getElementById("inviteState");
      const wakeStateEl = document.getElementById("wakeState");
      const wakeBtnEl = document.getElementById("wakeBtn");
      const wakeHintEl = document.getElementById("wakeHint");
      const inviteErrorEl = document.getElementById("inviteError");
      const logEl = document.getElementById("log");

      const workerId = getWorkerId();
      const inviteToken = new URLSearchParams(window.location.search).get("invite") || "";
      const seenNonces = new Map();

      let ws = null;
      let reconnectDelay = 500;
      let reconnectTimer = null;
      let heartbeatTimer = null;
      let verifyKeyPromise = null;
      let maxResultBytes = DEFAULT_MAX_RESULT_BYTES;
      let wakeLockSentinel = null;

      workerIdEl.textContent = workerId;
      inviteStateEl.textContent = inviteToken ? "present" : "missing";

      function appendLog(line) {
        const timestamp = new Date().toLocaleTimeString();
        logEl.textContent += `[${timestamp}] ${line}\n`;
        logEl.scrollTop = logEl.scrollHeight;
      }

      function setConnectionState(state) {
        connStateEl.textContent = state;
        connStateEl.className = "pill";
        connStateEl.classList.add(state);
      }

      function setWakeState(state, hint) {
        wakeStateEl.textContent = state;
        wakeStateEl.className = "pill";
        if (state === "active") {
          wakeStateEl.classList.add("connected");
        } else if (state === "unsupported" || state === "blocked") {
          wakeStateEl.classList.add("disconnected");
        } else {
          wakeStateEl.classList.add("connecting");
        }
        wakeHintEl.textContent = hint || "";
      }

      function isWakeLockSupported() {
        return Boolean(navigator.wakeLock && typeof navigator.wakeLock.request === "function");
      }

      async function requestWakeLock(reason) {
        if (!isWakeLockSupported()) {
          wakeBtnEl.disabled = true;
          setWakeState(
            "unsupported",
            "This browser cannot keep the screen awake from a webpage. Disable sleep manually in device settings.",
          );
          return;
        }

        if (document.visibilityState !== "visible") {
          setWakeState("paused", "Tab not visible. Keep this page in the foreground while volunteering.");
          return;
        }

        if (wakeLockSentinel) {
          setWakeState("active", "Screen wake lock is active.");
          return;
        }

        try {
          wakeLockSentinel = await navigator.wakeLock.request("screen");
          wakeLockSentinel.addEventListener("release", () => {
            wakeLockSentinel = null;
            if (document.visibilityState === "visible") {
              setWakeState("released", "Wake lock was released. Re-requesting...");
              requestWakeLock("released").catch(() => {});
            } else {
              setWakeState("paused", "Wake lock released while backgrounded.");
            }
          });
          setWakeState("active", "Screen wake lock is active.");
          appendLog(`wake lock active (${reason})`);
        } catch (error) {
          const message = error && error.message ? error.message : "request failed";
          setWakeState("blocked", `Wake lock failed: ${message}. Tap Enable and keep this tab visible.`);
          appendLog(`wake lock failed (${reason}): ${message}`);
        }
      }

      function initializeWakeLock() {
        wakeBtnEl.disabled = false;
        setWakeState("checking", "Requesting wake lock to keep the screen on.");
        requestWakeLock("startup").catch(() => {});

        wakeBtnEl.addEventListener("click", () => {
          requestWakeLock("manual").catch(() => {});
        });

        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "visible") {
            requestWakeLock("visible").catch(() => {});
          } else if (wakeLockSentinel) {
            setWakeState("paused", "Page hidden. Wake lock will resume when visible.");
          }
        });

        window.addEventListener("focus", () => {
          requestWakeLock("focus").catch(() => {});
        });
      }

      function send(message) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          return;
        }
        ws.send(JSON.stringify(message));
      }

      function scheduleReconnect() {
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
        }
        reconnectTimer = setTimeout(() => {
          connect();
        }, reconnectDelay);
        reconnectDelay = Math.min(Math.floor(reconnectDelay * 1.8), MAX_RECONNECT_MS);
      }

      function clearHeartbeat() {
        if (heartbeatTimer) {
          clearInterval(heartbeatTimer);
          heartbeatTimer = null;
        }
      }

      function startHeartbeat() {
        clearHeartbeat();
        heartbeatTimer = setInterval(() => {
          send({ type: "heartbeat", workerId });
        }, HEARTBEAT_INTERVAL_MS);
      }

      async function loadVerifyKey() {
        const response = await fetch(withBase("/api/public-config"), { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`public-config failed (${response.status})`);
        }
        const config = await response.json();
        if (!config || typeof config.jobSigningPublicKeySpkiB64 !== "string" || !config.jobSigningPublicKeySpkiB64) {
          throw new Error("Missing signing public key.");
        }
        const configuredResultLimit =
          config &&
          config.customJobLimits &&
          Number.isInteger(config.customJobLimits.maxResultBytes) &&
          config.customJobLimits.maxResultBytes > 0
            ? config.customJobLimits.maxResultBytes
            : null;
        if (configuredResultLimit) {
          maxResultBytes = configuredResultLimit;
        }
        const keyData = base64ToBytes(config.jobSigningPublicKeySpkiB64);
        return crypto.subtle.importKey(
          "spki",
          keyData.buffer,
          {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-256",
          },
          false,
          ["verify"],
        );
      }

      function ensureVerifyKey() {
        if (verifyKeyPromise) {
          return verifyKeyPromise;
        }
        verifyKeyPromise = loadVerifyKey().catch((error) => {
          verifyKeyPromise = null;
          throw error;
        });
        return verifyKeyPromise;
      }

      function cleanupNonces(nowMs) {
        for (const [nonce, exp] of seenNonces.entries()) {
          if (exp < nowMs) {
            seenNonces.delete(nonce);
          }
        }
      }

      function rememberNonceOrReject(nonce, exp) {
        const nowMs = Date.now();
        cleanupNonces(nowMs);
        if (seenNonces.has(nonce)) {
          return false;
        }
        seenNonces.set(nonce, exp);
        return true;
      }

      async function verifySignedTask(jobId, signedTask) {
        if (!signedTask || typeof signedTask !== "object") {
          throw new Error("Missing signed task envelope.");
        }
        if (signedTask.alg !== "RS256") {
          throw new Error("Unsupported signature algorithm.");
        }
        if (typeof signedTask.payload !== "string" || signedTask.payload.length === 0) {
          throw new Error("Missing signed payload.");
        }
        if (typeof signedTask.signature !== "string" || signedTask.signature.length === 0) {
          throw new Error("Missing signature.");
        }

        const verifyKey = await ensureVerifyKey();
        const payloadBytes = new TextEncoder().encode(signedTask.payload);
        const signatureBytes = base64UrlToBytes(signedTask.signature);
        const isValid = await crypto.subtle.verify(
          { name: "RSASSA-PKCS1-v1_5" },
          verifyKey,
          signatureBytes.buffer,
          payloadBytes,
        );
        if (!isValid) {
          throw new Error("Invalid task signature.");
        }

        let payload = null;
        try {
          payload = JSON.parse(signedTask.payload);
        } catch (_err) {
          throw new Error("Signed payload is not valid JSON.");
        }

        if (!payload || payload.typ !== "cluster_signed_job" || payload.v !== 1) {
          throw new Error("Signed payload type mismatch.");
        }
        if (payload.jobId !== jobId) {
          throw new Error("Signed payload jobId mismatch.");
        }
        if (typeof payload.nonce !== "string" || payload.nonce.length < 8) {
          throw new Error("Signed payload missing nonce.");
        }
        if (!Number.isInteger(payload.iat) || !Number.isInteger(payload.exp)) {
          throw new Error("Signed payload missing timestamps.");
        }
        const nowMs = Date.now();
        if (payload.exp < nowMs) {
          throw new Error("Signed payload expired.");
        }
        if (payload.iat > nowMs + MAX_CLOCK_SKEW_MS) {
          throw new Error("Signed payload iat too far in future.");
        }
        if (!rememberNonceOrReject(payload.nonce, payload.exp)) {
          throw new Error("Replay detected for signed payload.");
        }

        if (!payload.task || payload.task.op !== "run_js" || typeof payload.task.code !== "string") {
          throw new Error("Signed task payload invalid.");
        }
        if (!Number.isInteger(payload.task.timeoutMs) || payload.task.timeoutMs <= 0) {
          throw new Error("Signed task timeout invalid.");
        }

        return payload.task;
      }

      function executeScript(code, args, timeoutMs, resultBudgetBytes) {
        return new Promise((resolve) => {
          const blob = new Blob([EXECUTOR_SOURCE], { type: "application/javascript" });
          const runnerUrl = URL.createObjectURL(blob);
          const runner = new Worker(runnerUrl);
          let settled = false;
          const finish = (value) => {
            if (settled) {
              return;
            }
            settled = true;
            clearTimeout(timeout);
            runner.terminate();
            URL.revokeObjectURL(runnerUrl);
            resolve(value);
          };
          const timeout = setTimeout(() => {
            finish({
              ok: false,
              exitCode: 124,
              durationMs: timeoutMs,
              returnType: "none",
              returnValue: null,
              argsType: args === null ? "null" : Array.isArray(args) ? "array" : typeof args,
              logs: [],
              output: {
                text: "",
                truncated: false,
                bytes: 0,
              },
              error: {
                message: "Execution timeout exceeded",
                stack: null,
              },
              notes: [],
            });
          }, timeoutMs);

          runner.addEventListener("message", (event) => {
            const message = event.data || {};
            if (message.__cluster_exec_done__ !== true) {
              return;
            }
            if (Object.prototype.hasOwnProperty.call(message, "result")) {
              finish(message.result);
              return;
            }
            finish({
              ok: false,
              exitCode: 70,
              durationMs: 0,
              returnType: "none",
              returnValue: null,
              argsType: args === null ? "null" : Array.isArray(args) ? "array" : typeof args,
              logs: [],
              output: {
                text: "",
                truncated: false,
                bytes: 0,
              },
              error: {
                message: "Execution worker returned malformed response",
                stack: null,
              },
              notes: [],
            });
          });

          runner.addEventListener("error", () => {
            finish({
              ok: false,
              exitCode: 70,
              durationMs: 0,
              returnType: "none",
              returnValue: null,
              argsType: args === null ? "null" : Array.isArray(args) ? "array" : typeof args,
              logs: [],
              output: {
                text: "",
                truncated: false,
                bytes: 0,
              },
              error: {
                message: "Execution worker crashed",
                stack: null,
              },
              notes: [],
            });
          });

          runner.postMessage({
            code,
            args,
            resultBudgetBytes,
          });
        });
      }

      async function handleAddAssignment(jobId, payload) {
        if (!payload || payload.op !== "add" || !Number.isInteger(payload.a) || !Number.isInteger(payload.b)) {
          send({ type: "error", workerId, jobId: jobId || "unknown", error: "Malformed add payload" });
          return;
        }

        currentJobEl.textContent = jobId;
        appendLog(`processing add job ${jobId}: ${payload.a} + ${payload.b}`);
        const result = payload.a + payload.b;
        send({ type: "result", workerId, jobId, result });
        appendLog(`sent add result for ${jobId}`);
      }

      async function handleRunJsAssignment(jobId, payload) {
        currentJobEl.textContent = jobId;
        appendLog(`verifying signed JS job ${jobId}`);

        const verifiedTask = await verifySignedTask(jobId, payload.signedTask);
        appendLog(`running signed JS job ${jobId} timeout=${verifiedTask.timeoutMs}ms`);

        const resultBudgetBytes = Math.max(4 * 1024, Math.floor(maxResultBytes * 0.9));
        const result = await executeScript(verifiedTask.code, verifiedTask.args, verifiedTask.timeoutMs, resultBudgetBytes);
        send({ type: "result", workerId, jobId, result });
        appendLog(`sent JS result for ${jobId} exitCode=${result && result.exitCode !== undefined ? result.exitCode : "?"}`);
      }

      async function handleAssignMessage(message) {
        const { jobId, payload } = message;
        if (!jobId || !payload || typeof payload !== "object") {
          send({ type: "error", workerId, jobId: jobId || "unknown", error: "Malformed assignment payload" });
          return;
        }

        try {
          if (payload.op === "add") {
            await handleAddAssignment(jobId, payload);
          } else if (payload.op === "run_js") {
            await handleRunJsAssignment(jobId, payload);
          } else {
            throw new Error("Unsupported task operation.");
          }
        } catch (error) {
          const messageText = error && error.message ? error.message : "Task execution failure";
          appendLog(`job ${jobId} failed: ${messageText}`);
          send({ type: "error", workerId, jobId, error: messageText });
        } finally {
          currentJobEl.textContent = "idle";
          send({ type: "ready", workerId });
        }
      }

      async function connect() {
        if (!inviteToken) {
          setConnectionState("disconnected");
          inviteErrorEl.textContent = "Missing invite token. Ask the client owner for an invite URL.";
          appendLog("cannot connect without invite token");
          return;
        }

        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
          return;
        }

        try {
          await ensureVerifyKey();
        } catch (error) {
          setConnectionState("disconnected");
          appendLog(`failed to load signing key: ${error.message}`);
          scheduleReconnect();
          return;
        }

        setConnectionState("connecting");
        const protocol = window.location.protocol === "https:" ? "wss" : "ws";
        const url = `${protocol}://${window.location.host}${withBase("/ws/worker")}?invite=${encodeURIComponent(inviteToken)}`;
        const socket = new WebSocket(url);
        ws = socket;

        socket.addEventListener("open", () => {
          if (ws !== socket) {
            return;
          }
          if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            reconnectTimer = null;
          }
          reconnectDelay = 500;
          setConnectionState("connected");
          appendLog(`connected to ${url}`);
          send({ type: "register", workerId });
          send({ type: "ready", workerId });
          startHeartbeat();
        });

        socket.addEventListener("message", (event) => {
          if (ws !== socket) {
            return;
          }
          let message = null;
          try {
            message = JSON.parse(event.data);
          } catch (_err) {
            appendLog("received non-JSON message");
            return;
          }

          if (!message || typeof message !== "object") {
            return;
          }

          if (message.type === "assign") {
            handleAssignMessage(message).catch((error) => {
              appendLog(`assignment handler error: ${error.message}`);
            });
            return;
          }

          if (message.type === "ack" && message.jobId) {
            appendLog(`server acknowledged ${message.jobId}`);
            return;
          }

          if (message.type === "ack" && message.message === "registered") {
            appendLog(`registered as ${message.workerId}`);
            return;
          }

          if (message.type === "error") {
            appendLog(`server error: ${message.message || "unknown"}`);
          }
        });

        socket.addEventListener("close", (event) => {
          if (ws !== socket) {
            return;
          }
          ws = null;
          clearHeartbeat();
          setConnectionState("disconnected");
          if (event.code === 1008) {
            const serverReason = typeof event.reason === "string" ? event.reason.trim() : "";
            appendLog(
              `disconnected (${event.code}); invite rejected${serverReason ? ` (${serverReason})` : " or expired"}`,
            );
            inviteErrorEl.textContent = serverReason
              ? `${serverReason}. Request a fresh invite URL.`
              : "Invite rejected or expired. Request a fresh invite URL.";
            return;
          }
          if (event.code === 1005) {
            appendLog("disconnected (1005); connection dropped by network/proxy, retrying...");
          } else {
            appendLog(`disconnected (${event.code}); retrying...`);
          }
          scheduleReconnect();
        });

        socket.addEventListener("error", () => {
          if (ws !== socket) {
            return;
          }
          clearHeartbeat();
          setConnectionState("disconnected");
          appendLog("socket error (waiting for close/retry)");
        });
      }

      connect();
      initializeWakeLock();
    </script>
  </body>
</html>
