<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cluster Worker</title>
    <style>
      :root {
        --bg: #102542;
        --card: #1f3b62;
        --text: #edf2f4;
        --muted: #c2d4e7;
        --ok: #06d6a0;
        --warn: #ffd166;
        --error: #ef476f;
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Segoe UI", Tahoma, sans-serif;
        background: linear-gradient(130deg, #0b1f37, var(--bg) 50%, #1d3557);
        color: var(--text);
      }
      .wrap {
        max-width: 760px;
        margin: 1.2rem auto;
        padding: 1rem;
      }
      .card {
        background: color-mix(in srgb, var(--card) 85%, black);
        border: 1px solid #45648d;
        border-radius: 12px;
        padding: 1rem;
        margin-bottom: 1rem;
      }
      h1 {
        margin: 0 0 0.4rem 0;
      }
      .pill {
        display: inline-block;
        padding: 0.2rem 0.6rem;
        border-radius: 999px;
        font-weight: 700;
      }
      .connected {
        background: color-mix(in srgb, var(--ok) 20%, transparent);
        color: var(--ok);
      }
      .connecting {
        background: color-mix(in srgb, var(--warn) 20%, transparent);
        color: var(--warn);
      }
      .disconnected {
        background: color-mix(in srgb, var(--error) 20%, transparent);
        color: var(--error);
      }
      .mono {
        font-family: Consolas, Menlo, monospace;
      }
      .err {
        color: var(--error);
      }
      #log {
        white-space: pre-wrap;
        background: #0e1e35;
        border-radius: 8px;
        padding: 0.75rem;
        max-height: 280px;
        overflow-y: auto;
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card">
        <h1>Volunteer Worker</h1>
        <p>
          Status:
          <span id="connState" class="pill connecting">connecting</span>
        </p>
        <p>Worker ID: <span class="mono" id="workerId"></span></p>
        <p>Current Job: <span class="mono" id="currentJob">idle</span></p>
        <p>Invite: <span id="inviteState" class="mono"></span></p>
        <p id="inviteError" class="err"></p>
      </div>

      <div class="card">
        <strong>Log</strong>
        <div id="log"></div>
      </div>
    </div>

    <script>
      const WORKER_ID_KEY = "cluster_worker_id";
      const MAX_RECONNECT_MS = 10_000;
      const MAX_CLOCK_SKEW_MS = 30_000;
      const BASE_PATH = (() => {
        const path = window.location.pathname.replace(/\/+$/, "");
        if (path.endsWith("/worker")) {
          return path.slice(0, -"/worker".length);
        }
        return "";
      })();

      const EXECUTOR_SOURCE = `
self.onmessage = async (event) => {
  const payload = event.data || {};
  const code = typeof payload.code === "string" ? payload.code : "";
  const args = payload.args;
  try {
    const fn = new Function("args", '"use strict";\\n' + code);
    const rawResult = await fn(args);
    let normalized = null;
    try {
      const resultJson = JSON.stringify(rawResult);
      normalized = resultJson === undefined ? null : JSON.parse(resultJson);
    } catch (_resultError) {
      throw new Error("Result is not JSON-serializable");
    }
    self.postMessage({ ok: true, result: normalized });
  } catch (error) {
    const message = error && error.message ? error.message : "Execution failed";
    self.postMessage({ ok: false, error: message });
  }
};
`;

      function withBase(path) {
        return `${BASE_PATH}${path}`;
      }

      function randomSuffix() {
        return Math.random().toString(36).slice(2, 8);
      }

      function getWorkerId() {
        let workerId = localStorage.getItem(WORKER_ID_KEY);
        if (!workerId) {
          workerId = `worker-${randomSuffix()}`;
          localStorage.setItem(WORKER_ID_KEY, workerId);
        }
        return workerId;
      }

      function base64ToBytes(base64) {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i += 1) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
      }

      function base64UrlToBytes(base64url) {
        let base64 = String(base64url).replace(/-/g, "+").replace(/_/g, "/");
        while (base64.length % 4 !== 0) {
          base64 += "=";
        }
        return base64ToBytes(base64);
      }

      const connStateEl = document.getElementById("connState");
      const workerIdEl = document.getElementById("workerId");
      const currentJobEl = document.getElementById("currentJob");
      const inviteStateEl = document.getElementById("inviteState");
      const inviteErrorEl = document.getElementById("inviteError");
      const logEl = document.getElementById("log");

      const workerId = getWorkerId();
      const inviteToken = new URLSearchParams(window.location.search).get("invite") || "";
      const seenNonces = new Map();

      let ws = null;
      let reconnectDelay = 500;
      let reconnectTimer = null;
      let verifyKeyPromise = null;

      workerIdEl.textContent = workerId;
      inviteStateEl.textContent = inviteToken ? "present" : "missing";

      function appendLog(line) {
        const timestamp = new Date().toLocaleTimeString();
        logEl.textContent += `[${timestamp}] ${line}\n`;
        logEl.scrollTop = logEl.scrollHeight;
      }

      function setConnectionState(state) {
        connStateEl.textContent = state;
        connStateEl.className = "pill";
        connStateEl.classList.add(state);
      }

      function send(message) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          return;
        }
        ws.send(JSON.stringify(message));
      }

      function scheduleReconnect() {
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
        }
        reconnectTimer = setTimeout(() => {
          connect();
        }, reconnectDelay);
        reconnectDelay = Math.min(Math.floor(reconnectDelay * 1.8), MAX_RECONNECT_MS);
      }

      async function loadVerifyKey() {
        const response = await fetch(withBase("/api/public-config"), { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`public-config failed (${response.status})`);
        }
        const config = await response.json();
        if (!config || typeof config.jobSigningPublicKeySpkiB64 !== "string" || !config.jobSigningPublicKeySpkiB64) {
          throw new Error("Missing signing public key.");
        }
        const keyData = base64ToBytes(config.jobSigningPublicKeySpkiB64);
        return crypto.subtle.importKey(
          "spki",
          keyData.buffer,
          {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-256",
          },
          false,
          ["verify"],
        );
      }

      function ensureVerifyKey() {
        if (verifyKeyPromise) {
          return verifyKeyPromise;
        }
        verifyKeyPromise = loadVerifyKey().catch((error) => {
          verifyKeyPromise = null;
          throw error;
        });
        return verifyKeyPromise;
      }

      function cleanupNonces(nowMs) {
        for (const [nonce, exp] of seenNonces.entries()) {
          if (exp < nowMs) {
            seenNonces.delete(nonce);
          }
        }
      }

      function rememberNonceOrReject(nonce, exp) {
        const nowMs = Date.now();
        cleanupNonces(nowMs);
        if (seenNonces.has(nonce)) {
          return false;
        }
        seenNonces.set(nonce, exp);
        return true;
      }

      async function verifySignedTask(jobId, signedTask) {
        if (!signedTask || typeof signedTask !== "object") {
          throw new Error("Missing signed task envelope.");
        }
        if (signedTask.alg !== "RS256") {
          throw new Error("Unsupported signature algorithm.");
        }
        if (typeof signedTask.payload !== "string" || signedTask.payload.length === 0) {
          throw new Error("Missing signed payload.");
        }
        if (typeof signedTask.signature !== "string" || signedTask.signature.length === 0) {
          throw new Error("Missing signature.");
        }

        const verifyKey = await ensureVerifyKey();
        const payloadBytes = new TextEncoder().encode(signedTask.payload);
        const signatureBytes = base64UrlToBytes(signedTask.signature);
        const isValid = await crypto.subtle.verify(
          { name: "RSASSA-PKCS1-v1_5" },
          verifyKey,
          signatureBytes.buffer,
          payloadBytes,
        );
        if (!isValid) {
          throw new Error("Invalid task signature.");
        }

        let payload = null;
        try {
          payload = JSON.parse(signedTask.payload);
        } catch (_err) {
          throw new Error("Signed payload is not valid JSON.");
        }

        if (!payload || payload.typ !== "cluster_signed_job" || payload.v !== 1) {
          throw new Error("Signed payload type mismatch.");
        }
        if (payload.jobId !== jobId) {
          throw new Error("Signed payload jobId mismatch.");
        }
        if (typeof payload.nonce !== "string" || payload.nonce.length < 8) {
          throw new Error("Signed payload missing nonce.");
        }
        if (!Number.isInteger(payload.iat) || !Number.isInteger(payload.exp)) {
          throw new Error("Signed payload missing timestamps.");
        }
        const nowMs = Date.now();
        if (payload.exp < nowMs) {
          throw new Error("Signed payload expired.");
        }
        if (payload.iat > nowMs + MAX_CLOCK_SKEW_MS) {
          throw new Error("Signed payload iat too far in future.");
        }
        if (!rememberNonceOrReject(payload.nonce, payload.exp)) {
          throw new Error("Replay detected for signed payload.");
        }

        if (!payload.task || payload.task.op !== "run_js" || typeof payload.task.code !== "string") {
          throw new Error("Signed task payload invalid.");
        }
        if (!Number.isInteger(payload.task.timeoutMs) || payload.task.timeoutMs <= 0) {
          throw new Error("Signed task timeout invalid.");
        }

        return payload.task;
      }

      function executeScript(code, args, timeoutMs) {
        return new Promise((resolve, reject) => {
          const blob = new Blob([EXECUTOR_SOURCE], { type: "application/javascript" });
          const runnerUrl = URL.createObjectURL(blob);
          const runner = new Worker(runnerUrl);
          const timeout = setTimeout(() => {
            runner.terminate();
            URL.revokeObjectURL(runnerUrl);
            reject(new Error("Execution timeout exceeded"));
          }, timeoutMs);

          runner.addEventListener("message", (event) => {
            clearTimeout(timeout);
            runner.terminate();
            URL.revokeObjectURL(runnerUrl);
            const message = event.data || {};
            if (message.ok) {
              resolve(message.result);
              return;
            }
            reject(new Error(message.error || "Execution failed"));
          });

          runner.addEventListener("error", () => {
            clearTimeout(timeout);
            runner.terminate();
            URL.revokeObjectURL(runnerUrl);
            reject(new Error("Execution worker crashed"));
          });

          runner.postMessage({ code, args });
        });
      }

      async function handleAddAssignment(jobId, payload) {
        if (!payload || payload.op !== "add" || !Number.isInteger(payload.a) || !Number.isInteger(payload.b)) {
          send({ type: "error", workerId, jobId: jobId || "unknown", error: "Malformed add payload" });
          return;
        }

        currentJobEl.textContent = jobId;
        appendLog(`processing add job ${jobId}: ${payload.a} + ${payload.b}`);
        const result = payload.a + payload.b;
        send({ type: "result", workerId, jobId, result });
        appendLog(`sent add result for ${jobId}`);
      }

      async function handleRunJsAssignment(jobId, payload) {
        currentJobEl.textContent = jobId;
        appendLog(`verifying signed JS job ${jobId}`);

        const verifiedTask = await verifySignedTask(jobId, payload.signedTask);
        appendLog(`running signed JS job ${jobId} timeout=${verifiedTask.timeoutMs}ms`);

        const result = await executeScript(verifiedTask.code, verifiedTask.args, verifiedTask.timeoutMs);
        send({ type: "result", workerId, jobId, result });
        appendLog(`sent JS result for ${jobId}`);
      }

      async function handleAssignMessage(message) {
        const { jobId, payload } = message;
        if (!jobId || !payload || typeof payload !== "object") {
          send({ type: "error", workerId, jobId: jobId || "unknown", error: "Malformed assignment payload" });
          return;
        }

        try {
          if (payload.op === "add") {
            await handleAddAssignment(jobId, payload);
          } else if (payload.op === "run_js") {
            await handleRunJsAssignment(jobId, payload);
          } else {
            throw new Error("Unsupported task operation.");
          }
        } catch (error) {
          const messageText = error && error.message ? error.message : "Task execution failure";
          appendLog(`job ${jobId} failed: ${messageText}`);
          send({ type: "error", workerId, jobId, error: messageText });
        } finally {
          currentJobEl.textContent = "idle";
          send({ type: "ready", workerId });
        }
      }

      async function connect() {
        if (!inviteToken) {
          setConnectionState("disconnected");
          inviteErrorEl.textContent = "Missing invite token. Ask the client owner for an invite URL.";
          appendLog("cannot connect without invite token");
          return;
        }

        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
          return;
        }

        try {
          await ensureVerifyKey();
        } catch (error) {
          setConnectionState("disconnected");
          appendLog(`failed to load signing key: ${error.message}`);
          scheduleReconnect();
          return;
        }

        setConnectionState("connecting");
        const protocol = window.location.protocol === "https:" ? "wss" : "ws";
        const url = `${protocol}://${window.location.host}${withBase("/ws/worker")}?invite=${encodeURIComponent(inviteToken)}`;
        ws = new WebSocket(url);

        ws.addEventListener("open", () => {
          reconnectDelay = 500;
          setConnectionState("connected");
          appendLog(`connected to ${url}`);
          send({ type: "register", workerId });
          send({ type: "ready", workerId });
        });

        ws.addEventListener("message", (event) => {
          let message = null;
          try {
            message = JSON.parse(event.data);
          } catch (_err) {
            appendLog("received non-JSON message");
            return;
          }

          if (!message || typeof message !== "object") {
            return;
          }

          if (message.type === "assign") {
            handleAssignMessage(message).catch((error) => {
              appendLog(`assignment handler error: ${error.message}`);
            });
            return;
          }

          if (message.type === "ack" && message.jobId) {
            appendLog(`server acknowledged ${message.jobId}`);
            return;
          }

          if (message.type === "ack" && message.message === "registered") {
            appendLog(`registered as ${message.workerId}`);
            return;
          }

          if (message.type === "error") {
            appendLog(`server error: ${message.message || "unknown"}`);
          }
        });

        ws.addEventListener("close", (event) => {
          setConnectionState("disconnected");
          if (event.code === 1008) {
            appendLog(`disconnected (${event.code}); invite rejected or expired`);
            inviteErrorEl.textContent = "Invite rejected or expired. Request a fresh invite URL.";
            return;
          }
          appendLog(`disconnected (${event.code}); retrying...`);
          scheduleReconnect();
        });

        ws.addEventListener("error", () => {
          setConnectionState("disconnected");
          appendLog("socket error");
          try {
            ws.close();
          } catch (_err) {
            // Ignore close errors.
          }
        });
      }

      connect();
    </script>
  </body>
</html>
